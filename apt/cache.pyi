"""
This type stub file was generated by pyright.
"""

import apt_pkg
from typing import Any, Callable, Iterator, KeysView, List, Optional, Set, Union
from apt.package import Package
from apt.progress.base import AcquireProgress, InstallProgress, OpProgress

"""
This type stub file was generated by pyright.
"""
class FetchCancelledException(IOError):
    """Exception that is thrown when the user cancels a fetch operation."""
    ...


class FetchFailedException(IOError):
    """Exception that is thrown when fetching fails."""
    ...


class UntrustedException(FetchFailedException):
    """Exception that is thrown when fetching fails for trust reasons"""
    ...


class LockFailedException(IOError):
    """Exception that is thrown when locking fails."""
    ...


class CacheClosedException(Exception):
    """Exception that is thrown when the cache is used after close()."""
    ...


class _WrappedLock:
    """Wraps an apt_pkg.FileLock to raise LockFailedException.

    Initialized using a directory path."""
    def __init__(self, path: str) -> None:
        ...
    
    def __enter__(self) -> None:
        ...
    
    def __exit__(self, typ: object, value: object, traceback: object) -> None:
        ...
    


class Cache:
    """Dictionary-like package cache.

    The APT cache file contains a hash table mapping names of binary
    packages to their metadata. A Cache object is the in-core
    representation of the same. It provides access to APTs idea of the
    list of available packages.

    The cache can be used like a mapping from package names to Package
    objects (although only getting items is supported).

    Keyword arguments:
    progress -- a OpProgress object,
    rootdir  -- an alternative root directory. if that is given the system
    sources.list and system lists/files are not read, only file relative
    to the given rootdir,
    memonly  -- build the cache in memory only.


    .. versionchanged:: 1.0

        The cache now supports package names with special architecture
        qualifiers such as :all and :native. It does not export them
        in :meth:`keys()`, though, to keep :meth:`keys()` a unique set.
    """
    def __init__(self, progress: Optional[OpProgress] = ..., rootdir: Optional[str] = ..., memonly: bool = ...) -> None:
        ...
    
    def fix_broken(self) -> None:
        """Fix broken packages."""
        ...
    
    def open(self, progress: Optional[OpProgress] = ...) -> None:
        """Open the package cache, after that it can be used like
        a dictionary
        """
        ...
    
    def close(self) -> None:
        """Close the package cache"""
        ...
    
    def __enter__(self) -> Cache:
        """Enter the with statement"""
        ...
    
    def __exit__(self, exc_type: object, exc_value: object, traceback: object) -> None:
        """Exit the with statement"""
        ...
    
    def __getitem__(self, key: object) -> Package:
        """look like a dictionary (get key)"""
        ...
    
    def get(self, key: object, default: object = ...) -> Any:
        """Return *self*[*key*] or *default* if *key* not in *self*.

        .. versionadded:: 1.1
        """
        ...
    
    def __iter__(self) -> Iterator[Package]:
        ...
    
    def has_key(self, key: object) -> bool:
        ...
    
    def __contains__(self, key: object) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    def keys(self) -> List[str]:
        ...
    
    def get_changes(self) -> List[Package]:
        """Get the marked changes"""
        ...
    
    def upgrade(self, dist_upgrade: bool = ...) -> None:
        """Upgrade all packages.

        If the parameter *dist_upgrade* is True, new dependencies will be
        installed as well (and conflicting packages may be removed). The
        default value is False.
        """
        ...
    
    @property
    def required_download(self) -> int:
        """Get the size of the packages that are required to download."""
        ...
    
    @property
    def required_space(self) -> int:
        """Get the size of the additional required space on the fs."""
        ...
    
    @property
    def req_reinstall_pkgs(self) -> Set[str]:
        """Return the packages not downloadable packages in reqreinst state."""
        ...
    
    def fetch_archives(self, progress: Optional[AcquireProgress] = ..., fetcher: Optional[apt_pkg.Acquire] = ..., allow_unauthenticated: Optional[bool] = ...) -> int:
        """Fetch the archives for all packages marked for install/upgrade.

        You can specify either an :class:`apt.progress.base.AcquireProgress()`
        object for the parameter *progress*, or specify an already
        existing :class:`apt_pkg.Acquire` object for the parameter *fetcher*.

        The return value of the function is undefined. If an error occurred,
        an exception of type :class:`FetchFailedException` or
        :class:`FetchCancelledException` is raised.

        The keyword-only parameter *allow_unauthenticated* specifies whether
        to allow unauthenticated downloads. If not specified, it defaults to
        the configuration option `APT::Get::AllowUnauthenticated`.

        .. versionadded:: 0.8.0
        """
        ...
    
    def is_virtual_package(self, pkgname: str) -> bool:
        """Return whether the package is a virtual package."""
        ...
    
    def get_providing_packages(self, pkgname: str, candidate_only: bool = ..., include_nonvirtual: bool = ...) -> List[Package]:
        """Return a list of all packages providing a package.

        Return a list of packages which provide the virtual package of the
        specified name.

        If 'candidate_only' is False, return all packages with at
        least one version providing the virtual package. Otherwise,
        return only those packages where the candidate version
        provides the virtual package.

        If 'include_nonvirtual' is True then it will search for all
        packages providing pkgname, even if pkgname is not itself
        a virtual pkg.
        """
        ...
    
    def update(self, fetch_progress: Optional[AcquireProgress] = ..., pulse_interval: int = ..., raise_on_error: bool = ..., sources_list: Optional[str] = ...) -> int:
        """Run the equivalent of apt-get update.

        You probably want to call open() afterwards, in order to utilise the
        new cache. Otherwise, the old cache will be used which can lead to
        strange bugs.

        The first parameter *fetch_progress* may be set to an instance of
        apt.progress.FetchProgress, the default is apt.progress.FetchProgress()
        .
        sources_list -- Update a alternative sources.list than the default.
        Note that the sources.list.d directory is ignored in this case
        """
        ...
    
    def install_archives(self, pm: apt_pkg.PackageManager, install_progress: InstallProgress) -> int:
        """
        The first parameter *pm* refers to an object returned by
        apt_pkg.PackageManager().

        The second parameter *install_progress* refers to an InstallProgress()
        object of the module apt.progress.

        This releases a system lock in newer versions, if there is any,
        and reestablishes it afterwards.
        """
        ...
    
    def commit(self, fetch_progress: Optional[AcquireProgress] = ..., install_progress: Optional[InstallProgress] = ..., allow_unauthenticated: Optional[bool] = ...) -> bool:
        """Apply the marked changes to the cache.

        The first parameter, *fetch_progress*, refers to a FetchProgress()
        object as found in apt.progress, the default being
        apt.progress.FetchProgress().

        The second parameter, *install_progress*, is a
        apt.progress.InstallProgress() object.

        The keyword-only parameter *allow_unauthenticated* specifies whether
        to allow unauthenticated downloads. If not specified, it defaults to
        the configuration option `APT::Get::AllowUnauthenticated`.
        """
        ...
    
    def clear(self) -> None:
        """Unmark all changes"""
        ...
    
    def cache_post_change(self) -> None:
        "called internally if the cache has changed, emit a signal then"
        ...
    
    def cache_pre_change(self) -> None:
        """called internally if the cache is about to change, emit
        a signal then"""
        ...
    
    def connect(self, name: str, callback: Union[Callable[..., None], str]) -> None:
        """Connect to a signal.

        .. deprecated:: 1.0

            Please use connect2() instead, as this function is very
            likely to cause a memory leak.
        """
        ...
    
    def connect2(self, name: str, callback: Callable[..., Any], *args: object, **kwds: object) -> None:
        """Connect to a signal.

        The callback will be passed the cache as an argument, and
        any arguments passed to this function. Make sure that, if you
        pass a method of a class as your callback, your class does not
        contain a reference to the cache.

        Cyclic references to the cache can cause issues if the Cache object
        is replaced by a new one, because the cache keeps a lot of objects and
        tens of open file descriptors.

        currently only used for cache_{post,pre}_{changed,open}.

        .. versionadded:: 1.0
        """
        ...
    
    def actiongroup(self) -> apt_pkg.ActionGroup:
        """Return an `ActionGroup` object for the current cache.

        Action groups can be used to speedup actions. The action group is
        active as soon as it is created, and disabled when the object is
        deleted or when release() is called.

        You can use the action group as a context manager, this is the
        recommended way::

            with cache.actiongroup():
                for package in my_selected_packages:
                    package.mark_install()

        This way, the action group is automatically released as soon as the
        with statement block is left. It also has the benefit of making it
        clear which parts of the code run with a action group and which
        don't.
        """
        ...
    
    @property
    def dpkg_journal_dirty(self) -> bool:
        """Return True if the dpkg was interrupted

        All dpkg operations will fail until this is fixed, the action to
        fix the system if dpkg got interrupted is to run
        'dpkg --configure -a' as root.
        """
        ...
    
    @property
    def broken_count(self) -> int:
        """Return the number of packages with broken dependencies."""
        ...
    
    @property
    def delete_count(self) -> int:
        """Return the number of packages marked for deletion."""
        ...
    
    @property
    def install_count(self) -> int:
        """Return the number of packages marked for installation."""
        ...
    
    @property
    def keep_count(self) -> int:
        """Return the number of packages marked as keep."""
        ...
    


class ProblemResolver:
    """Resolve problems due to dependencies and conflicts.

    The first argument 'cache' is an instance of apt.Cache.
    """
    def __init__(self, cache: Cache) -> None:
        ...
    
    def clear(self, package: Package) -> None:
        """Reset the package to the default state."""
        ...
    
    def protect(self, package: Package) -> None:
        """Protect a package so it won't be removed."""
        ...
    
    def remove(self, package: Package) -> None:
        """Mark a package for removal."""
        ...
    
    def resolve(self) -> None:
        """Resolve dependencies, try to remove packages where needed."""
        ...
    
    def resolve_by_keep(self) -> None:
        """Resolve dependencies, do not try to remove packages."""
        ...
    


class Filter:
    """Filter base class"""
    def apply(self, pkg: Package) -> bool:
        """Filter function, return True if the package matchs a
        filter criteria and False otherwise
        """
        ...
    


class MarkedChangesFilter(Filter):
    """Filter that returns all marked changes"""
    def apply(self, pkg: Package) -> bool:
        ...
    


class InstalledFilter(Filter):
    """Filter that returns all installed packages.

    .. versionadded:: 1.0.0
    """
    def apply(self, pkg: Package) -> bool:
        ...
    


class _FilteredCacheHelper:
    """Helper class for FilteredCache to break a reference cycle."""
    def __init__(self, cache: Cache) -> None:
        ...
    
    def set_filter(self, filter: Filter) -> None:
        """Set the current active filter."""
        ...
    
    def filter_cache_post_change(self, cache: Cache) -> None:
        """Called internally if the cache changes, emit a signal then."""
        ...
    


class FilteredCache:
    """A package cache that is filtered.

    Can work on a existing cache or create a new one
    """
    def __init__(self, cache: Optional[Cache] = ..., progress: Optional[OpProgress] = ...) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, key: str) -> Package:
        ...
    
    def __iter__(self) -> Iterator[Package]:
        ...
    
    def keys(self) -> KeysView[str]:
        ...
    
    def has_key(self, key: object) -> bool:
        ...
    
    def __contains__(self, key: object) -> bool:
        ...
    
    def set_filter(self, filter: Filter) -> None:
        """Set the current active filter."""
        ...
    
    def filter_cache_post_change(self) -> None:
        """Called internally if the cache changes, emit a signal then."""
        ...
    
    def __getattr__(self, key: str) -> Any:
        """we try to look exactly like a real cache."""
        ...
    


def cache_pre_changed(cache: Cache) -> None:
    ...

def cache_post_changed(cache: Cache) -> None:
    ...

if __name__ == "__main__":
    ...
