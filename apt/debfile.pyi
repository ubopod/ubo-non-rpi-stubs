"""
This type stub file was generated by pyright.
"""

import apt
from typing import Iterable, List, Optional, Tuple, Union

"""
This type stub file was generated by pyright.
"""
class NoDebArchiveException(IOError):
    """Exception which is raised if a file is no Debian archive."""
    ...


class DebPackage:
    """A Debian Package (.deb file)."""
    debug = ...
    def __init__(self, filename: Optional[str] = ..., cache: Optional[apt.Cache] = ...) -> None:
        ...
    
    def open(self, filename: str) -> None:
        """open given debfile"""
        ...
    
    def __getitem__(self, key: str) -> str:
        ...
    
    def __contains__(self, key: str) -> bool:
        ...
    
    @property
    def filelist(self) -> List[str]:
        """return the list of files in the deb."""
        ...
    
    @property
    def control_filelist(self) -> List[str]:
        """return the list of files in control.tar.gz"""
        ...
    
    @property
    def conflicts(self) -> List[List[Tuple[str, str, str]]]:
        """List of packages conflicting with this package."""
        ...
    
    @property
    def depends(self) -> List[List[Tuple[str, str, str]]]:
        """List of packages on which this package depends on."""
        ...
    
    @property
    def provides(self) -> List[List[Tuple[str, str, str]]]:
        """List of virtual packages which are provided by this package."""
        ...
    
    @property
    def replaces(self) -> List[List[Tuple[str, str, str]]]:
        """List of packages which are replaced by this package."""
        ...
    
    def replaces_real_pkg(self, pkgname: str, oper: str, ver: str) -> bool:
        """Return True if a given non-virtual package is replaced.

        Return True if the deb packages replaces a real (not virtual)
        packages named (pkgname, oper, ver).
        """
        ...
    
    def check_conflicts(self) -> bool:
        """Check if there are conflicts with existing or selected packages.

        Check if the package conflicts with a existing or to be installed
        package. Return True if the pkg is OK.
        """
        ...
    
    def check_breaks_existing_packages(self) -> bool:
        """
        check if installing the package would break exsisting
        package on the system, e.g. system has:
        smc depends on smc-data (= 1.4)
        and user tries to installs smc-data 1.6
        """
        ...
    
    def compare_to_version_in_cache(self, use_installed: bool = ...) -> int:
        """Compare the package to the version available in the cache.

        Checks if the package is already installed or availabe in the cache
        and if so in what version, returns one of (VERSION_NONE,
        VERSION_OUTDATED, VERSION_SAME, VERSION_NEWER).
        """
        ...
    
    def check(self, allow_downgrade: bool = ...) -> bool:
        """Check if the package is installable."""
        ...
    
    def satisfy_depends_str(self, dependsstr: str) -> bool:
        """Satisfy the dependencies in the given string."""
        ...
    
    @property
    def missing_deps(self) -> List[str]:
        """Return missing dependencies."""
        ...
    
    @property
    def required_changes(self) -> Tuple[List[str], List[str], List[str]]:
        """Get the changes required to satisfy the dependencies.

        Returns: a tuple with (install, remove, unauthenticated)
        """
        ...
    
    @staticmethod
    def to_hex(in_data: str) -> str:
        ...
    
    @staticmethod
    def to_strish(in_data: Union[str, Iterable[int]]) -> str:
        ...
    
    def control_content(self, name: str) -> str:
        """return the content of a specific control.tar.gz file"""
        ...
    
    def data_content(self, name: str) -> str:
        """return the content of a specific control.tar.gz file"""
        ...
    
    def install(self, install_progress: Optional[apt.progress.base.InstallProgress] = ...) -> int:
        """Install the package."""
        ...
    


class DscSrcPackage(DebPackage):
    """A locally available source package."""
    def __init__(self, filename: Optional[str] = ..., cache: Optional[apt.Cache] = ...) -> None:
        ...
    
    @property
    def depends(self) -> List[List[Tuple[str, str, str]]]:
        """Return the dependencies of the package"""
        ...
    
    @property
    def conflicts(self) -> List[List[Tuple[str, str, str]]]:
        """Return the dependencies of the package"""
        ...
    
    @property
    def filelist(self) -> List[str]:
        """Return the list of files associated with this dsc file"""
        ...
    
    def open(self, file: str) -> None:
        """Open the package."""
        ...
    
    def check(self, allow_downgrade: bool = ...) -> bool:
        """Check if the package is installable.

        The second parameter is ignored and only exists for compatibility
        with parent type."""
        ...
    


if __name__ == "__main__":
    ...
