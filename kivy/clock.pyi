"""
This type stub file was generated by pyright.
"""

import time
from sys import platform
from os import environ
from kivy._clock import CyClockBase, CyClockBaseFree

"""
This type stub file was generated by pyright.
"""
__all__ = ('Clock', 'ClockNotRunningError', 'ClockEvent', 'FreeClockEvent', 'CyClockBase', 'CyClockBaseFree', 'triggered', 'ClockBaseBehavior', 'ClockBaseInterruptBehavior', 'ClockBaseInterruptFreeBehavior', 'ClockBase', 'ClockBaseInterrupt', 'ClockBaseFreeInterruptAll', 'ClockBaseFreeInterruptOnly', 'mainthread')
if platform in ('win32', 'cygwin'):
    _kernel32 = ...
else:
    _libc_usleep = ...
class ClockBaseBehavior:
    '''The base of the kivy clock.

    :parameters:

        `async_lib`: string
            The async library to use when the clock is run asynchronously.
            Can be one of, `"asyncio"` when the standard library asyncio
            should be used, or `"trio"` if the trio library should be used.

            It defaults to `'asyncio'` or the value in the environmental
            variable `KIVY_EVENTLOOP` if set. :meth:`init_async_lib` can also
            be called directly to set the library.
    '''
    _dt = ...
    _last_fps_tick = ...
    _start_tick = ...
    _fps = ...
    _rfps = ...
    _fps_counter = ...
    _rfps_counter = ...
    _frames = ...
    _frames_displayed = ...
    _events_duration = ...
    _duration_count = ...
    _sleep_time = ...
    _duration_ts0 = ...
    MIN_SLEEP = ...
    SLEEP_UNDERSHOOT = ...
    _async_lib = ...
    _async_wait_for = ...
    def __init__(self, async_lib=..., **kwargs) -> None:
        ...
    
    def init_async_lib(self, lib):
        """Manually sets the async library to use internally, when running in
        a asynchronous manner.

        This can be called anytime before the kivy event loop has started,
        but not once the kivy App is running.

        :parameters:

            `lib`: string
                The async library to use when the clock is run asynchronously.
                Can be one of, `"asyncio"` when the standard library asyncio
                should be used, or `"trio"` if the trio library should be used.
        """
        ...
    
    @property
    def frametime(self):
        '''Time spent between the last frame and the current frame
        (in seconds).

        .. versionadded:: 1.8.0
        '''
        ...
    
    @property
    def frames(self):
        '''Number of internal frames (not necessarily drawn) from the start of
        the clock.

        .. versionadded:: 1.8.0
        '''
        ...
    
    @property
    def frames_displayed(self):
        '''Number of displayed frames from the start of the clock.
        '''
        ...
    
    def usleep(self, microseconds):
        '''Sleeps for the number of microseconds.
        '''
        ...
    
    def idle(self):
        '''(internal) waits here until the next frame.
        '''
        ...
    
    async def async_idle(self):
        '''(internal) async version of :meth:`idle`.
        '''
        ...
    
    def tick(self):
        '''Advance the clock to the next step. Must be called every frame.
        The default clock has a tick() function called by the core Kivy
        framework.'''
        ...
    
    async def async_tick(self):
        '''async version of :meth:`tick`. '''
        ...
    
    def pre_idle(self):
        '''Called before :meth:`idle` by :meth:`tick`.
        '''
        ...
    
    def post_idle(self, ts, current):
        '''Called after :meth:`idle` by :meth:`tick`.
        '''
        ...
    
    def tick_draw(self):
        '''Tick the drawing counter.
        '''
        ...
    
    def get_fps(self):
        '''Get the current average FPS calculated by the clock.
        '''
        ...
    
    def get_rfps(self):
        '''Get the current "real" FPS calculated by the clock.
        This counter reflects the real framerate displayed on the screen.

        In contrast to get_fps(), this function returns a counter of the
        number of frames, not the average of frames per second.
        '''
        ...
    
    def get_time(self):
        '''Get the last tick made by the clock.'''
        ...
    
    def get_boottime(self):
        '''Get the time in seconds from the application start.'''
        ...
    
    time = ...
    def handle_exception(self, e):
        ...
    


class ClockBaseInterruptBehavior(ClockBaseBehavior):
    '''A kivy clock which can be interrupted during a frame to execute events.
    '''
    interupt_next_only = ...
    _event = ...
    _async_event = ...
    _get_min_timeout_func = ...
    def __init__(self, interupt_next_only=..., **kwargs) -> None:
        ...
    
    def init_async_lib(self, lib):
        ...
    
    def usleep(self, microseconds):
        ...
    
    async def async_usleep(self, microseconds):
        ...
    
    def on_schedule(self, event):
        ...
    
    def idle(self):
        ...
    
    async def async_idle(self):
        ...
    


class ClockBaseInterruptFreeBehavior(ClockBaseInterruptBehavior):
    '''A base class for the clock that interrupts the sleep interval for
    free events.
    '''
    def __init__(self, **kwargs) -> None:
        ...
    
    def on_schedule(self, event):
        ...
    


class ClockBase(ClockBaseBehavior, CyClockBase):
    '''The ``default`` kivy clock. See module for details.
    '''
    _sleep_obj = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def usleep(self, microseconds):
        ...
    


class ClockBaseInterrupt(ClockBaseInterruptBehavior, CyClockBase):
    '''The ``interrupt`` kivy clock. See module for details.
    '''
    ...


class ClockBaseFreeInterruptAll(ClockBaseInterruptFreeBehavior, CyClockBaseFree):
    '''The ``free_all`` kivy clock. See module for details.
    '''
    ...


class ClockBaseFreeInterruptOnly(ClockBaseInterruptFreeBehavior, CyClockBaseFree):
    '''The ``free_only`` kivy clock. See module for details.
    '''
    def idle(self):
        ...
    
    async def async_idle(self):
        ...
    


def mainthread(func):
    '''Decorator that will schedule the call of the function for the next
    available frame in the mainthread. It can be useful when you use
    :class:`~kivy.network.urlrequest.UrlRequest` or when you do Thread
    programming: you cannot do any OpenGL-related work in a thread.

    Please note that this method will return directly and no result can be
    returned::

        @mainthread
        def callback(self, *args):
            print('The request succeeded!',
                  'This callback is called in the main thread.')


        self.req = UrlRequest(url='http://...', on_success=callback)

    .. versionadded:: 1.8.0
    '''
    ...

def triggered(timeout=..., interval=...):
    '''Decorator that will trigger the call of the function at the specified
    timeout, through the method :meth:`CyClockBase.create_trigger`. Subsequent
    calls to the decorated function (while the timeout is active) are ignored.

    It can be helpful when an expensive function (i.e. call to a server) can be
    triggered by different methods. Setting a proper timeout will delay the
    calling and only one of them will be triggered.

        @triggered(timeout, interval=False)
        def callback(id):
            print('The callback has been called with id=%d' % id)

        >> callback(id=1)
        >> callback(id=2)
        The callback has been called with id=2

    The decorated callback can also be unscheduled using:

        >> callback.cancel()

    .. versionadded:: 1.10.1
    '''
    ...

if 'KIVY_DOC_INCLUDE' in environ:
    Clock: ClockBase = ...
else:
    _classes = ...
    _clk = ...
    Clock: ClockBase = ...
