"""
This type stub file was generated by pyright.
"""

from kivy.event import EventDispatcher

'''
Kinetic effect
==============

.. versionadded:: 1.7.0

The :class:`KineticEffect` is the base class that is used to compute the
velocity out of a movement. When the movement is finished, the effect will
compute the position of the movement according to the velocity, and reduce the
velocity with a friction. The movement stop until the velocity is 0.

Conceptually, the usage could be::

    >>> effect = KineticEffect()
    >>> effect.start(10)
    >>> effect.update(15)
    >>> effect.update(30)
    >>> effect.stop(48)

Over the time, you will start a movement of a value, update it, and stop the
movement. At this time, you'll get the movement value into
:attr:`KineticEffect.value`. On the example i've typed manually, the computed
velocity will be::

    >>> effect.velocity
    3.1619100231163046

After multiple clock interaction, the velocity will decrease according to
:attr:`KineticEffect.friction`. The computed value will be stored in
:attr:`KineticEffect.value`. The output of this `value` could be::

    46.30038145219605
    54.58302451968686
    61.9229016256196
    # ...

'''
__all__ = ('KineticEffect', )
class KineticEffect(EventDispatcher):
    '''Kinetic effect class. See module documentation for more information.
    '''
    velocity = ...
    friction = ...
    value = ...
    is_manual = ...
    max_history = ...
    min_distance = ...
    min_velocity = ...
    std_dt = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def apply_distance(self, distance): # -> None:
        ...
    
    def start(self, val, t=...): # -> None:
        '''Start the movement.

        :Parameters:
            `val`: float or int
                Value of the movement
            `t`: float, defaults to None
                Time when the movement happen. If no time is set, it will use
                time.time()
        '''
        ...
    
    def update(self, val, t=...): # -> None:
        '''Update the movement.

        See :meth:`start` for the arguments.
        '''
        ...
    
    def stop(self, val, t=...): # -> None:
        '''Stop the movement.

        See :meth:`start` for the arguments.
        '''
        ...
    
    def cancel(self): # -> None:
        '''Cancel a movement. This can be used in case :meth:`stop` cannot be
        called. It will reset :attr:`is_manual` to False, and compute the
        movement if the velocity is > 0.
        '''
        ...
    
    def update_velocity(self, dt): # -> None:
        '''(internal) Update the velocity according to the frametime and
        friction.
        '''
        ...
    


