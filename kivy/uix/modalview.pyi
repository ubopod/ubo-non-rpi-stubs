"""
This type stub file was generated by pyright.
"""

from kivy.uix.anchorlayout import AnchorLayout

"""
ModalView
=========

.. versionadded:: 1.4.0

The :class:`ModalView` widget is used to create modal views. By default, the
view will cover the whole "main" window.

Remember that the default size of a Widget is size_hint=(1, 1). If you don't
want your view to be fullscreen, either use size hints with values lower than
1 (for instance size_hint=(.8, .8)) or deactivate the size_hint and use fixed
size attributes.

Examples
--------

Example of a simple 400x400 Hello world view::

    view = ModalView(size_hint=(None, None), size=(400, 400))
    view.add_widget(Label(text='Hello world'))

By default, any click outside the view will dismiss it. If you don't
want that, you can set :attr:`ModalView.auto_dismiss` to False::

    view = ModalView(auto_dismiss=False)
    view.add_widget(Label(text='Hello world'))
    view.open()

To manually dismiss/close the view, use the :meth:`ModalView.dismiss` method of
the ModalView instance::

    view.dismiss()

Both :meth:`ModalView.open` and :meth:`ModalView.dismiss` are bind-able. That
means you can directly bind the function to an action, e.g. to a button's
on_press ::

    # create content and add it to the view
    content = Button(text='Close me!')
    view = ModalView(auto_dismiss=False)
    view.add_widget(content)

    # bind the on_press event of the button to the dismiss function
    content.bind(on_press=view.dismiss)

    # open the view
    view.open()


ModalView Events
----------------

There are four events available: `on_pre_open` and `on_open` which are raised
when the view is opening; `on_pre_dismiss` and `on_dismiss` which are raised
when the view is closed.

For `on_dismiss`, you can prevent the view from closing by explicitly
returning `True` from your callback::

    def my_callback(instance):
        print('ModalView', instance, 'is being dismissed, but is prevented!')
        return True
    view = ModalView()
    view.add_widget(Label(text='Hello world'))
    view.bind(on_dismiss=my_callback)
    view.open()


.. versionchanged:: 1.5.0
    The ModalView can be closed by hitting the escape key on the
    keyboard if the :attr:`ModalView.auto_dismiss` property is True (the
    default).

"""
__all__ = ('ModalView', )
class ModalView(AnchorLayout):
    """ModalView class. See module documentation for more information.

    :Events:
        `on_pre_open`:
            Fired before the ModalView is opened. When this event is fired
            ModalView is not yet added to window.
        `on_open`:
            Fired when the ModalView is opened.
        `on_pre_dismiss`:
            Fired before the ModalView is closed.
        `on_dismiss`:
            Fired when the ModalView is closed. If the callback returns True,
            the dismiss will be canceled.

    .. versionchanged:: 1.11.0
        Added events `on_pre_open` and `on_pre_dismiss`.

    .. versionchanged:: 2.0.0
        Added property 'overlay_color'.

    .. versionchanged:: 2.1.0
        Marked `attach_to` property as deprecated.

    """
    auto_dismiss = ...
    attach_to = ...
    background_color = ...
    background = ...
    border = ...
    overlay_color = ...
    _anim_alpha = ...
    _anim_duration = ...
    _window = ...
    _is_open = ...
    _touch_started_inside = ...
    __events__ = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def open(self, *_args, **kwargs): # -> None:
        """Display the modal in the Window.

        When the view is opened, it will be faded in with an animation. If you
        don't want the animation, use::

            view.open(animation=False)

        """
        ...
    
    def dismiss(self, *_args, **kwargs): # -> None:
        """ Close the view if it is open.

        If you really want to close the view, whatever the on_dismiss
        event returns, you can use the *force* keyword argument::

            view = ModalView()
            view.dismiss(force=True)

        When the view is dismissed, it will be faded out before being
        removed from the parent. If you don't want this animation, use::

            view.dismiss(animation=False)

        """
        ...
    
    def on_motion(self, etype, me): # -> Literal[True]:
        ...
    
    def on_touch_down(self, touch): # -> Literal[True]:
        """ touch down event handler. """
        ...
    
    def on_touch_move(self, touch): # -> Literal[True]:
        """ touch moved event handler. """
        ...
    
    def on_touch_up(self, touch): # -> Literal[True]:
        """ touch up event handler. """
        ...
    
    def on__anim_alpha(self, _instance, value): # -> None:
        """ animation progress callback. """
        ...
    
    def on_pre_open(self): # -> None:
        """ default pre-open event handler. """
        ...
    
    def on_open(self): # -> None:
        """ default open event handler. """
        ...
    
    def on_pre_dismiss(self): # -> None:
        """ default pre-dismiss event handler. """
        ...
    
    def on_dismiss(self): # -> None:
        """ default dismiss event handler. """
        ...
    


if __name__ == '__main__':
    content = ...
    view = ...
    layout = ...
