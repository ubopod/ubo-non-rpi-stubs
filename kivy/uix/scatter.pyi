"""
This type stub file was generated by pyright.
"""

from kivy.uix.widget import Widget

'''
Scatter
=======

.. image:: images/scatter.gif
    :align: right

:class:`Scatter` is used to build interactive widgets that can be translated,
rotated and scaled with two or more fingers on a multitouch system.

Scatter has its own matrix transformation: the modelview matrix is changed
before the children are drawn and the previous matrix is restored when the
drawing is finished. That makes it possible to perform rotation, scaling and
translation over the entire children tree without changing any widget
properties. That specific behavior makes the scatter unique, but there are some
advantages / constraints that you should consider:

#. The children are positioned relative to the scatter similarly to a
   :mod:`~kivy.uix.relativelayout.RelativeLayout`. So when dragging the
   scatter, the position of the children don't change, only the position of
   the scatter does.
#. The scatter size has no impact on the size of its children.
#. If you want to resize the scatter, use scale, not size (read #2). Scale
   transforms both the scatter and its children, but does not change size.
#. The scatter is not a layout. You must manage the size of the children
   yourself.

For touch events, the scatter converts from the parent matrix to the scatter
matrix automatically in on_touch_down/move/up events. If you are doing things
manually, you will need to use :meth:`~kivy.uix.widget.Widget.to_parent` and
:meth:`~kivy.uix.widget.Widget.to_local`.

Usage
-----

By default, the Scatter does not have a graphical representation: it is a
container only. The idea is to combine the Scatter with another widget, for
example an :class:`~kivy.uix.image.Image`::

    scatter = Scatter()
    image = Image(source='sun.jpg')
    scatter.add_widget(image)

Control Interactions
--------------------

By default, all interactions are enabled. You can selectively disable
them using the do_rotation, do_translation and do_scale properties.

Disable rotation::

    scatter = Scatter(do_rotation=False)

Allow only translation::

    scatter = Scatter(do_rotation=False, do_scale=False)

Allow only translation on x axis::

    scatter = Scatter(do_rotation=False, do_scale=False,
                      do_translation_y=False)


Automatic Bring to Front
------------------------

If the :attr:`Scatter.auto_bring_to_front` property is True, the scatter
widget will be removed and re-added to the parent when it is touched
(brought to front, above all other widgets in the parent). This is useful
when you are manipulating several scatter widgets and don't want the active
one to be partially hidden.

Scale Limitation
----------------

We are using a 32-bit matrix in double representation. That means we have
a limit for scaling. You cannot do infinite scaling down/up with our
implementation. Generally, you don't hit the minimum scale (because you don't
see it on the screen), but the maximum scale is 9.99506983235e+19 (2^66).

You can also limit the minimum and maximum scale allowed::

    scatter = Scatter(scale_min=.5, scale_max=3.)

Behavior
--------

.. versionchanged:: 1.1.0
    If no control interactions are enabled, then the touch handler will never
    return True.

'''
__all__ = ('Scatter', 'ScatterPlane')
class Scatter(Widget):
    '''Scatter class. See module documentation for more information.

    :Events:
        `on_transform_with_touch`:
            Fired when the scatter has been transformed by user touch
            or multitouch, such as panning or zooming.
        `on_bring_to_front`:
            Fired when the scatter is brought to the front.

    .. versionchanged:: 1.9.0
        Event `on_bring_to_front` added.

    .. versionchanged:: 1.8.0
        Event `on_transform_with_touch` added.
    '''
    __events__ = ...
    auto_bring_to_front = ...
    do_translation_x = ...
    do_translation_y = ...
    do_translation = ...
    translation_touches = ...
    do_rotation = ...
    do_scale = ...
    do_collide_after_children = ...
    scale_min = ...
    scale_max = ...
    transform = ...
    transform_inv = ...
    bbox = ...
    rotation = ...
    scale = ...
    center = ...
    pos = ...
    x = ...
    y = ...
    def get_right(self):
        ...
    
    def set_right(self, value): # -> None:
        ...
    
    right = ...
    def get_top(self):
        ...
    
    def set_top(self, value): # -> None:
        ...
    
    top = ...
    def get_center_x(self):
        ...
    
    def set_center_x(self, value): # -> None:
        ...
    
    center_x = ...
    def get_center_y(self):
        ...
    
    def set_center_y(self, value): # -> None:
        ...
    
    center_y = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def on_transform(self, instance, value): # -> None:
        ...
    
    def collide_point(self, x, y):
        ...
    
    def to_parent(self, x, y, **k): # -> tuple[Any, Any]:
        ...
    
    def to_local(self, x, y, **k): # -> tuple[Any, Any]:
        ...
    
    def apply_transform(self, trans, post_multiply=..., anchor=...): # -> None:
        '''
        Transforms the scatter by applying the "trans" transformation
        matrix (on top of its current transformation state). The resultant
        matrix can be found in the :attr:`~Scatter.transform` property.

        :Parameters:
            `trans`: :class:`~kivy.graphics.transformation.Matrix`.
                Transformation matrix to be applied to the scatter widget.
            `anchor`: tuple, defaults to (0, 0).
                The point to use as the origin of the transformation
                (uses local widget space).
            `post_multiply`: bool, defaults to False.
                If True, the transform matrix is post multiplied
                (as if applied before the current transform).

        Usage example::

            from kivy.graphics.transformation import Matrix
            mat = Matrix().scale(3, 3, 3)
            scatter_instance.apply_transform(mat)

        '''
        ...
    
    def transform_with_touch(self, touch): # -> bool:
        ...
    
    def on_motion(self, etype, me): # -> Literal[True] | None:
        ...
    
    def on_touch_down(self, touch): # -> bool:
        ...
    
    def on_touch_move(self, touch): # -> Literal[True] | None:
        ...
    
    def on_transform_with_touch(self, touch): # -> None:
        '''
        Called when a touch event has transformed the scatter widget.
        By default this does nothing, but can be overridden by derived
        classes that need to react to transformations caused by user
        input.

        :Parameters:
            `touch`:
                The touch object which triggered the transformation.

        .. versionadded:: 1.8.0
        '''
        ...
    
    def on_bring_to_front(self, touch): # -> None:
        '''
        Called when a touch event causes the scatter to be brought to the
        front of the parent (only if :attr:`auto_bring_to_front` is True)

        :Parameters:
            `touch`:
                The touch object which brought the scatter to front.

        .. versionadded:: 1.9.0
        '''
        ...
    
    def on_touch_up(self, touch): # -> Literal[True] | None:
        ...
    


class ScatterPlane(Scatter):
    '''This is essentially an unbounded Scatter widget. It's a convenience
       class to make it easier to handle infinite planes.
    '''
    def __init__(self, **kwargs) -> None:
        ...
    
    def collide_point(self, x, y): # -> Literal[True]:
        ...
    


