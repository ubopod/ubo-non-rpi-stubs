"""
This type stub file was generated by pyright.
"""

from kivy.config import Config
from kivy.uix.stencilview import StencilView
from kivy.app import App

'''
ScrollView
==========

.. versionadded:: 1.0.4

The :class:`ScrollView` widget provides a scrollable/pannable viewport that is
clipped at the scrollview's bounding box.

.. note::
    Use :class:`~kivy.uix.recycleview.RecycleView` for generating large
    numbers of widgets in order to display many data items.


Scrolling Behavior
------------------

The ScrollView accepts only one child and applies a viewport/window to
it according to the :attr:`~ScrollView.scroll_x` and
:attr:`~ScrollView.scroll_y` properties. Touches are analyzed to
determine if the user wants to scroll or control the child in some
other manner: you cannot do both at the same time. To determine if
interaction is a scrolling gesture, these properties are used:

    - :attr:`~ScrollView.scroll_distance`: the minimum distance to travel,
      defaults to 20 pixels.
    - :attr:`~ScrollView.scroll_timeout`: the maximum time period, defaults
      to 55 milliseconds.

If a touch travels :attr:`~ScrollView.scroll_distance` pixels within the
:attr:`~ScrollView.scroll_timeout` period, it is recognized as a scrolling
gesture and translation (scroll/pan) will begin. If the timeout occurs, the
touch down event is dispatched to the child instead (no translation).

The default value for those settings can be changed in the configuration file::

    [widgets]
    scroll_timeout = 250
    scroll_distance = 20

.. versionadded:: 1.1.1

    ScrollView now animates scrolling in Y when a mousewheel is used.


Limiting to the X or Y Axis
---------------------------

By default, the ScrollView allows scrolling along both the X and Y axes. You
can explicitly disable scrolling on an axis by setting the
:attr:`~ScrollView.do_scroll_x` or :attr:`~ScrollView.do_scroll_y` properties
to False.


Managing the Content Size and Position
--------------------------------------

The ScrollView manages the position of its children similarly to a
:class:`~kivy.uix.relativelayout.RelativeLayout` but does not use the
:attr:`~kivy.uix.widget.Widget.size_hint`. You must
carefully specify the :attr:`~kivy.uix.widget.Widget.size` of your content to
get the desired scroll/pan effect.

By default, the :attr:`~kivy.uix.widget.Widget.size_hint` is (1, 1), so the
content size will fit your ScrollView
exactly (you will have nothing to scroll). You must deactivate at least one of
the size_hint instructions (x or y) of the child to enable scrolling.
Setting :attr:`~kivy.uix.widget.Widget.size_hint_min` to not be None will
also enable scrolling for that dimension when the :class:`ScrollView` is
smaller than the minimum size.

To scroll a :class:`~kivy.uix.gridlayout.GridLayout` on it's Y-axis/vertically,
set the child's width  to that of the ScrollView (size_hint_x=1), and set
the size_hint_y property to None::

    from kivy.uix.gridlayout import GridLayout
    from kivy.uix.button import Button
    from kivy.uix.scrollview import ScrollView
    from kivy.core.window import Window
    from kivy.app import runTouchApp

    layout = GridLayout(cols=1, spacing=10, size_hint_y=None)
    # Make sure the height is such that there is something to scroll.
    layout.bind(minimum_height=layout.setter('height'))
    for i in range(100):
        btn = Button(text=str(i), size_hint_y=None, height=40)
        layout.add_widget(btn)
    root = ScrollView(size_hint=(1, None), size=(Window.width, Window.height))
    root.add_widget(layout)

    runTouchApp(root)


Kv Example::

    ScrollView:
        do_scroll_x: False
        do_scroll_y: True

        Label:
            size_hint_y: None
            height: self.texture_size[1]
            text_size: self.width, None
            padding: 10, 10
            text:
                'really some amazing text\\n' * 100

Overscroll Effects
------------------

.. versionadded:: 1.7.0

When scrolling would exceed the bounds of the :class:`ScrollView`, it
uses a :class:`~kivy.effects.scroll.ScrollEffect` to handle the
overscroll. These effects can perform actions like bouncing back,
changing opacity, or simply preventing scrolling beyond the normal
boundaries. Note that complex effects may perform many computations,
which can be slow on weaker hardware.

You can change what effect is being used by setting
:attr:`~ScrollView.effect_cls` to any effect class. Current options
include:

    - :class:`~kivy.effects.scroll.ScrollEffect`: Does not allow
      scrolling beyond the :class:`ScrollView` boundaries.
    - :class:`~kivy.effects.dampedscroll.DampedScrollEffect`: The
      current default. Allows the user to scroll beyond the normal
      boundaries, but has the content spring back once the
      touch/click is released.
    - :class:`~kivy.effects.opacityscroll.OpacityScrollEffect`: Similar
      to the :class:`~kivy.effect.dampedscroll.DampedScrollEffect`, but
      also reduces opacity during overscroll.

You can also create your own scroll effect by subclassing one of these,
then pass it as the :attr:`~ScrollView.effect_cls` in the same way.

Alternatively, you can set :attr:`~ScrollView.effect_x` and/or
:attr:`~ScrollView.effect_y` to an *instance* of the effect you want to
use. This will override the default effect set in
:attr:`~ScrollView.effect_cls`.

All the effects are located in the :mod:`kivy.effects`.

'''
__all__ = ('ScrollView', )
_scroll_distance = ...
if Config:
    _scroll_timeout = ...
    _scroll_distance = ...
class ScrollView(StencilView):
    '''ScrollView class. See module documentation for more information.

    :Events:
        `on_scroll_start`
            Generic event fired when scrolling starts from touch.
        `on_scroll_move`
            Generic event fired when scrolling move from touch.
        `on_scroll_stop`
            Generic event fired when scrolling stops from touch.

    .. versionchanged:: 1.9.0
        `on_scroll_start`, `on_scroll_move` and `on_scroll_stop` events are
        now dispatched when scrolling to handle nested ScrollViews.

    .. versionchanged:: 1.7.0
        `auto_scroll`, `scroll_friction`, `scroll_moves`, `scroll_stoptime' has
        been deprecated, use :attr:`effect_cls` instead.
    '''
    scroll_distance = ...
    scroll_wheel_distance = ...
    scroll_timeout = ...
    scroll_x = ...
    scroll_y = ...
    do_scroll_x = ...
    do_scroll_y = ...
    do_scroll = ...
    always_overscroll = ...
    vbar = ...
    hbar = ...
    bar_color = ...
    bar_inactive_color = ...
    bar_width = ...
    bar_pos_x = ...
    bar_pos_y = ...
    bar_pos = ...
    bar_margin = ...
    effect_cls = ...
    effect_x = ...
    effect_y = ...
    viewport_size = ...
    scroll_type = ...
    smooth_scroll_end = ...
    _viewport = ...
    _bar_color = ...
    _effect_x_start_width = ...
    _effect_y_start_height = ...
    _update_effect_bounds_ev = ...
    _bind_inactive_bar_color_ev = ...
    def on__viewport(self, instance, value): # -> None:
        ...
    
    __events__ = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def on_effect_x(self, instance, value): # -> None:
        ...
    
    def on_effect_y(self, instance, value): # -> None:
        ...
    
    def on_effect_cls(self, instance, cls): # -> None:
        ...
    
    def to_local(self, x, y, **k): # -> tuple[Any, Any]:
        ...
    
    def to_parent(self, x, y, **k): # -> tuple[Any, Any]:
        ...
    
    def simulate_touch_down(self, touch): # -> Literal[True] | None:
        ...
    
    def on_motion(self, etype, me): # -> Literal[True] | None:
        ...
    
    def on_touch_down(self, touch): # -> Literal[True] | None:
        ...
    
    def on_scroll_start(self, touch, check_children=...):
        ...
    
    def on_touch_move(self, touch): # -> bool | None:
        ...
    
    def on_scroll_move(self, touch):
        ...
    
    def on_touch_up(self, touch): # -> bool | None:
        ...
    
    def on_scroll_stop(self, touch, check_children=...): # -> bool | None:
        ...
    
    def scroll_to(self, widget, padding=..., animate=...): # -> None:
        '''Scrolls the viewport to ensure that the given widget is visible,
        optionally with padding and animation. If animate is True (the
        default), then the default animation parameters will be used.
        Otherwise, it should be a dict containing arguments to pass to
        :class:`~kivy.animation.Animation` constructor.

        .. versionadded:: 1.9.1
        '''
        ...
    
    def convert_distance_to_scroll(self, dx, dy): # -> tuple[Literal[0], Literal[0]] | tuple[Any | Literal[0], Any | Literal[1]]:
        '''Convert a distance in pixels to a scroll distance, depending on the
        content size and the scrollview size.

        The result will be a tuple of scroll distance that can be added to
        :data:`scroll_x` and :data:`scroll_y`
        '''
        ...
    
    def update_from_scroll(self, *largs): # -> None:
        '''Force the reposition of the content, according to current value of
        :attr:`scroll_x` and :attr:`scroll_y`.

        This method is automatically called when one of the :attr:`scroll_x`,
        :attr:`scroll_y`, :attr:`pos` or :attr:`size` properties change, or
        if the size of the content changes.
        '''
        ...
    
    def add_widget(self, widget, *args, **kwargs): # -> None:
        ...
    
    def remove_widget(self, widget, *args, **kwargs): # -> None:
        ...
    


if __name__ == '__main__':
    class ScrollViewApp(App):
        def build(self): # -> GridLayout:
            ...
        
    
    
