"""
This type stub file was generated by pyright.
"""

from os import environ
from kivy.config import Config
from kivy.uix.behaviors import ButtonBehavior, FocusBehavior
from kivy.uix.widget import Widget
from kivy.uix.bubble import Bubble
from kivy.uix.image import Image
from kivy.app import App

'''
Text Input
==========

.. versionadded:: 1.0.4

.. image:: images/textinput-mono.jpg
.. image:: images/textinput-multi.jpg

The :class:`TextInput` widget provides a box for editable plain text.

Unicode, multiline, cursor navigation, selection and clipboard features
are supported.

The :class:`TextInput` uses two different coordinate systems:

* (x, y) - coordinates in pixels, mostly used for rendering on screen.
* (col, row) - cursor index in characters / lines, used for selection
  and cursor movement.


Usage example
-------------

To create a multiline :class:`TextInput` (the 'enter' key adds a new line)::

    from kivy.uix.textinput import TextInput
    textinput = TextInput(text='Hello world')

To create a singleline :class:`TextInput`, set the :class:`TextInput.multiline`
property to False (the 'enter' key will defocus the TextInput and emit an
:meth:`TextInput.on_text_validate` event)::

    def on_enter(instance, value):
        print('User pressed enter in', instance)

    textinput = TextInput(text='Hello world', multiline=False)
    textinput.bind(on_text_validate=on_enter)

The textinput's text is stored in its :attr:`TextInput.text` property. To run a
callback when the text changes::

    def on_text(instance, value):
        print('The widget', instance, 'have:', value)

    textinput = TextInput()
    textinput.bind(text=on_text)

You can set the :class:`focus <kivy.uix.behaviors.FocusBehavior>` to a
Textinput, meaning that the input box will be highlighted and keyboard focus
will be requested::

    textinput = TextInput(focus=True)

The textinput is defocused if the 'escape' key is pressed, or if another
widget requests the keyboard. You can bind a callback to the focus property to
get notified of focus changes::

    def on_focus(instance, value):
        if value:
            print('User focused', instance)
        else:
            print('User defocused', instance)

    textinput = TextInput()
    textinput.bind(focus=on_focus)

See :class:`~kivy.uix.behaviors.FocusBehavior`, from which the
:class:`TextInput` inherits, for more details.


Selection
---------

The selection is automatically updated when the cursor position changes.
You can get the currently selected text from the
:attr:`TextInput.selection_text` property.

Handles
-------

One can enable :attr:`TextInput.use_handles` property to enable or disable
the usage of selection handles. This property is True by default on mobiles.

Selection Handles uses the class :class:`Selector` as the base class for
the selection handles. You can customize the color for selection handles
like so ::

    <Selector>
        color: 0, 1, 0, 1
        # or <Textinput_instance>.selection_color or app.selection_color

TextInput instantiates the selection handles and stores it in the following
properties. :attr:`TextInput._handle_middle`,
:attr:`TextInput._handle_left`, :attr:`TextInput._handle_right`.

You should set the selection template before the Instantiating TextInput,
so as to get the selection handles to take the changes you set to apply.

Filtering
---------

You can control which text can be added to the :class:`TextInput` by
overwriting :meth:`TextInput.insert_text`. Every string that is typed, pasted
or inserted by any other means into the :class:`TextInput` is passed through
this function. By overwriting it you can reject or change unwanted characters.

For example, to write only in capitalized characters::

    class CapitalInput(TextInput):

        def insert_text(self, substring, from_undo=False):
            s = substring.upper()
            return super().insert_text(s, from_undo=from_undo)

Or to only allow floats (0 - 9 and a single period)::

    class FloatInput(TextInput):

        pat = re.compile('[^0-9]')
        def insert_text(self, substring, from_undo=False):
            pat = self.pat
            if '.' in self.text:
                s = re.sub(pat, '', substring)
            else:
                s = '.'.join(
                    re.sub(pat, '', s)
                    for s in substring.split('.', 1)
                )
            return super().insert_text(s, from_undo=from_undo)

Default shortcuts
-----------------

=============== ========================================================
   Shortcuts    Description
--------------- --------------------------------------------------------
Left            Move cursor to left
Right           Move cursor to right
Up              Move cursor to up
Down            Move cursor to down
Home            Move cursor at the beginning of the line
End             Move cursor at the end of the line
PageUp          Move cursor to 3 lines before
PageDown        Move cursor to 3 lines after
Backspace       Delete the selection or character before the cursor
Del             Delete the selection of character after the cursor
Shift + <dir>   Start a text selection. Dir can be Up, Down, Left or
                Right
Control + c     Copy selection
Control + x     Cut selection
Control + v     Paste clipboard content
Control + a     Select all the content
Control + z     undo
Control + r     redo
=============== ========================================================

.. note::
    To enable Emacs-style keyboard shortcuts, you can use
    :class:`~kivy.uix.behaviors.emacs.EmacsBehavior`.

'''
__all__ = ('TextInput', )
if 'KIVY_DOC' in environ:
    def triggered(*_, **__): # -> Callable[..., Callable[..., Any]]:
        ...
    
else:
    ...
Cache_register = ...
Cache_append = ...
Cache_get = ...
Cache_remove = ...
FL_IS_LINEBREAK = ...
FL_IS_WORDBREAK = ...
FL_IS_NEWLINE = ...
Clipboard = ...
CutBuffer = ...
MarkupLabel = ...
_platform = ...
_textinput_list = ...
_is_osx = ...
_is_desktop = ...
_scroll_distance = ...
if Config:
    _is_desktop = ...
    _scroll_timeout = ...
    _scroll_distance = ...
if 'KIVY_DOC' not in environ:
    ...
class Selector(ButtonBehavior, Image):
    '''Default template for the selection Handles

    In order to customize the look of the Selection Handles,
    you should adjust its template like so ::

        <Selector>
            color: 1, 0, 1, 1
    '''
    window = ...
    target = ...
    matrix = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def update_transform(self, cb): # -> None:
        ...
    
    def transform_touch(self, touch): # -> None:
        ...
    
    def on_touch_down(self, touch): # -> bool | None:
        ...
    


class TextInputCutCopyPaste(Bubble):
    textinput = ...
    but_cut = ...
    but_copy = ...
    but_paste = ...
    but_selectall = ...
    matrix = ...
    _check_parent_ev = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def update_transform(self, cb): # -> None:
        ...
    
    def transform_touch(self, touch): # -> None:
        ...
    
    def on_touch_down(self, touch): # -> Literal[True] | None:
        ...
    
    def on_touch_up(self, touch): # -> Literal[True] | None:
        ...
    
    def on_textinput(self, instance, value): # -> None:
        ...
    
    def on_parent(self, instance, value): # -> None:
        ...
    
    def do(self, action): # -> None:
        ...
    
    def hide(self): # -> None:
        ...
    


class TextInput(FocusBehavior, Widget):
    '''TextInput class. See module documentation for more information.

    :Events:
        `on_text_validate`
            Fired only in multiline=False mode when the user hits 'enter'.
            This will also unfocus the textinput.
        `on_double_tap`
            Fired when a double tap happens in the text input. The default
            behavior selects the text around the cursor position. More info at
            :meth:`on_double_tap`.
        `on_triple_tap`
            Fired when a triple tap happens in the text input. The default
            behavior selects the line around the cursor position. More info at
            :meth:`on_triple_tap`.
        `on_quad_touch`
            Fired when four fingers are touching the text input. The default
            behavior selects the whole text. More info at
            :meth:`on_quad_touch`.

    .. warning::
        When changing a :class:`TextInput` property that requires re-drawing,
        e.g. modifying the :attr:`text`, the updates occur on the next
        clock cycle and not instantly. This might cause any changes to the
        :class:`TextInput` that occur between the modification and the next
        cycle to be ignored, or to use previous values. For example, after
        a update to the :attr:`text`, changing the cursor in the same clock
        frame will move it using the previous text and will likely end up in an
        incorrect position. The solution is to schedule any updates to occur
        on the next clock cycle using
        :meth:`~kivy.clock.ClockBase.schedule_once`.

    .. Note::
        Selection is cancelled when TextInput is focused. If you need to
        show selection when TextInput is focused, you should delay
        (use Clock.schedule) the call to the functions for selecting
        text (select_all, select_text).

    .. versionchanged:: 1.10.0
        `background_disabled_active` has been removed.

    .. versionchanged:: 1.9.0

        :class:`TextInput` now inherits from
        :class:`~kivy.uix.behaviors.FocusBehavior`.
        :attr:`~kivy.uix.behaviors.FocusBehavior.keyboard_mode`,
        :meth:`~kivy.uix.behaviors.FocusBehavior.show_keyboard`,
        :meth:`~kivy.uix.behaviors.FocusBehavior.hide_keyboard`,
        :meth:`~kivy.uix.behaviors.FocusBehavior.focus`,
        and :attr:`~kivy.uix.behaviors.FocusBehavior.input_type`
        have been removed since they are now inherited
        from :class:`~kivy.uix.behaviors.FocusBehavior`.

    .. versionchanged:: 1.7.0
        `on_double_tap`, `on_triple_tap` and `on_quad_touch` events added.

    .. versionchanged:: 2.1.0
        :attr:`~kivy.uix.behaviors.FocusBehavior.keyboard_suggestions`
        is now inherited from :class:`~kivy.uix.behaviors.FocusBehavior`.
    '''
    __events__ = ...
    _resolved_base_dir = ...
    def __init__(self, **kwargs) -> None:
        ...
    
    def on_text_validate(self): # -> None:
        ...
    
    def cursor_index(self, cursor=...): # -> int:
        '''Return the cursor index in the text/value.
        '''
        ...
    
    def cursor_offset(self): # -> Literal[0]:
        '''Get the cursor x offset on the current line.
        '''
        ...
    
    def get_cursor_from_index(self, index): # -> tuple[Literal[0], Literal[0]] | tuple[Any, int] | tuple[int, int]:
        '''Return the (col, row) of the cursor from text index.
        '''
        ...
    
    def select_text(self, start, end): # -> None:
        ''' Select a portion of text displayed in this TextInput.

        .. versionadded:: 1.4.0

        :Parameters:
            `start`
                Index of textinput.text from where to start selection
            `end`
                Index of textinput.text till which the selection should be
                displayed
        '''
        ...
    
    def select_all(self): # -> None:
        ''' Select all of the text displayed in this TextInput.

        .. versionadded:: 1.4.0
        '''
        ...
    
    re_indent = ...
    def insert_text(self, substring, from_undo=...): # -> None:
        '''Insert new text at the current cursor position. Override this
        function in order to pre-process text for input validation.
        '''
        ...
    
    def reset_undo(self): # -> None:
        '''Reset undo and redo lists from memory.

        .. versionadded:: 1.3.0

        '''
        ...
    
    def do_redo(self): # -> None:
        '''Do redo operation.

        .. versionadded:: 1.3.0

        This action re-does any command that has been un-done by
        do_undo/ctrl+z. This function is automatically called when
        `ctrl+r` keys are pressed.
        '''
        ...
    
    def do_undo(self): # -> None:
        '''Do undo operation.

        .. versionadded:: 1.3.0

        This action un-does any edits that have been made since the last
        call to reset_undo().
        This function is automatically called when `ctrl+z` keys are pressed.
        '''
        ...
    
    def do_backspace(self, from_undo=..., mode=...): # -> None:
        '''Do backspace operation from the current cursor position.
        This action might do several things:

            - removing the current selection if available.
            - removing the previous char and move the cursor back.
            - do nothing, if we are at the start.

        '''
        ...
    
    _re_whitespace = ...
    @property
    def pgmove_speed(self): # -> int:
        """how much vertical distance hitting pg_up or pg_down will move
        """
        ...
    
    def do_cursor_movement(self, action, control=..., alt=...):
        '''Move the cursor relative to its current position.
        Action can be one of :

            - cursor_left: move the cursor to the left
            - cursor_right: move the cursor to the right
            - cursor_up: move the cursor on the previous line
            - cursor_down: move the cursor on the next line
            - cursor_home: move the cursor at the start of the current line
            - cursor_end: move the cursor at the end of current line
            - cursor_pgup: move one "page" before
            - cursor_pgdown: move one "page" after

        In addition, the behavior of certain actions can be modified:

            - control + cursor_left: move the cursor one word to the left
            - control + cursor_right: move the cursor one word to the right
            - control + cursor_up: scroll up one line
            - control + cursor_down: scroll down one line
            - control + cursor_home: go to beginning of text
            - control + cursor_end: go to end of text
            - alt + cursor_up: shift line(s) up
            - alt + cursor_down: shift line(s) down

        .. versionchanged:: 1.9.1

        '''
        ...
    
    def get_cursor_from_xy(self, x, y): # -> tuple[int, int]:
        '''Return the (col, row) of the cursor from an (x, y) position.
        '''
        ...
    
    def get_max_scroll_x(self): # -> int:
        '''
        Return how many pixels it needs to scroll to the right
        to reveal the remaining content of a text that extends
        beyond the visible width of a TextInput
        '''
        ...
    
    def cancel_selection(self): # -> None:
        '''Cancel current selection (if any).
        '''
        ...
    
    def delete_selection(self, from_undo=...): # -> None:
        '''Delete the current text selection (if any).
        '''
        ...
    
    def long_touch(self, dt): # -> None:
        ...
    
    def cancel_long_touch_event(self): # -> None:
        ...
    
    def on_double_tap(self): # -> None:
        '''This event is dispatched when a double tap happens
        inside TextInput. The default behavior is to select the
        word around the current cursor position. Override this to provide
        different behavior. Alternatively, you can bind to this
        event to provide additional functionality.
        '''
        ...
    
    def on_triple_tap(self): # -> None:
        '''This event is dispatched when a triple tap happens
        inside TextInput. The default behavior is to select the
        line around current cursor position. Override this to provide
        different behavior. Alternatively, you can bind to this
        event to provide additional functionality.
        '''
        ...
    
    def on_quad_touch(self): # -> None:
        '''This event is dispatched when four fingers are touching
        inside TextInput. The default behavior is to select all text.
        Override this to provide different behavior. Alternatively,
        you can bind to this event to provide additional functionality.
        '''
        ...
    
    def on_touch_down(self, touch): # -> bool | None:
        ...
    
    def on_touch_move(self, touch): # -> bool | None:
        ...
    
    def on_touch_up(self, touch): # -> bool | None:
        ...
    
    def scroll_text_from_swipe(self, touch): # -> bool:
        ...
    
    def cut(self): # -> None:
        ''' Copy current selection to clipboard then delete it from TextInput.

        .. versionadded:: 1.8.0

        '''
        ...
    
    def copy(self, data=...): # -> None:
        ''' Copy the value provided in argument `data` into current clipboard.
        If data is not of type string it will be converted to string.
        If no data is provided then current selection if present is copied.

        .. versionadded:: 1.8.0

        '''
        ...
    
    def paste(self): # -> None:
        ''' Insert text from system :class:`~kivy.core.clipboard.Clipboard`
        into the :class:`~kivy.uix.textinput.TextInput` at current cursor
        position.

        .. versionadded:: 1.8.0

        '''
        ...
    
    def on_cursor_blink(self, instance, value): # -> None:
        """trigger blink event reset to switch blinking while focused"""
        ...
    
    def on_cursor(self, instance, value): # -> None:
        """
        When the cursor is moved, reset cursor blinking to keep it showing,
        and update all the graphics.
        """
        ...
    
    def on_size(self, instance, value): # -> None:
        ...
    
    _tokenize_delimiters = ...
    def keyboard_on_key_down(self, window, keycode, text, modifiers):
        ...
    
    def keyboard_on_key_up(self, window, keycode): # -> None:
        ...
    
    def keyboard_on_textinput(self, window, text): # -> None:
        ...
    
    _ime_composition = ...
    _ime_cursor = ...
    def window_on_textedit(self, window, ime_input): # -> None:
        ...
    
    def on__hint_text(self, instance, value): # -> None:
        ...
    
    _lines = ...
    _hint_text_lines = ...
    _editable = ...
    _insert_int_pat = ...
    _insert_float_pat = ...
    _cursor_blink = ...
    _cursor_visual_pos = ...
    _cursor_visual_height = ...
    readonly = ...
    text_validate_unfocus = ...
    multiline = ...
    do_wrap = ...
    password = ...
    password_mask = ...
    cursor_blink = ...
    cursor = ...
    cursor_col = ...
    cursor_row = ...
    cursor_pos = ...
    cursor_color = ...
    cursor_width = ...
    line_height = ...
    tab_width = ...
    padding_x = ...
    def on_padding_x(self, instance, value): # -> None:
        ...
    
    padding_y = ...
    def on_padding_y(self, instance, value): # -> None:
        ...
    
    padding = ...
    halign = ...
    scroll_x = ...
    scroll_y = ...
    selection_color = ...
    border = ...
    background_normal = ...
    background_disabled_normal = ...
    background_active = ...
    background_color = ...
    foreground_color = ...
    disabled_foreground_color = ...
    use_bubble = ...
    use_handles = ...
    scroll_from_swipe = ...
    scroll_distance = ...
    scroll_timeout = ...
    def get_sel_from(self): # -> int | None:
        ...
    
    selection_from = ...
    def get_sel_to(self): # -> int | None:
        ...
    
    selection_to = ...
    selection_text = ...
    def on_selection_text(self, instance, value): # -> None:
        ...
    
    text = ...
    font_name = ...
    font_size = ...
    font_context = ...
    font_family = ...
    base_direction = ...
    text_language = ...
    _hint_text = ...
    hint_text = ...
    hint_text_color = ...
    auto_indent = ...
    replace_crlf = ...
    allow_copy = ...
    minimum_height = ...
    line_spacing = ...
    lines_to_scroll = ...
    input_filter = ...
    handle_image_middle = ...
    def on_handle_image_middle(self, instance, value): # -> None:
        ...
    
    handle_image_left = ...
    def on_handle_image_left(self, instance, value): # -> None:
        ...
    
    handle_image_right = ...
    def on_handle_image_right(self, instance, value): # -> None:
        ...
    
    write_tab = ...


if __name__ == '__main__':
    KV = ...
    class TextInputApp(App):
        time = ...
        def build(self): # -> _ | Any | None:
            ...
        
        def update_time(self, dt): # -> None:
            ...
        
    
    
