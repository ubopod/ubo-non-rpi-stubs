"""
This type stub file was generated by pyright.
"""

import sys
from _collections_abc import dict_items, dict_keys, dict_values
from _typeshed import SupportsItems, SupportsKeysAndGetItem, SupportsRichComparison, SupportsRichComparisonT
from typing import Any, ClassVar, Generic, NoReturn, SupportsIndex, TypeVar, final, overload
from typing_extensions import Self
from types import GenericAlias
from collections.abc import Callable, ItemsView, Iterable, Iterator, KeysView, Mapping, MutableMapping, MutableSequence, Sequence, ValuesView

if sys.version_info >= (3, 9):
    ...
if sys.version_info >= (3, 10):
    ...
else:
    ...
__all__ = ["ChainMap", "Counter", "OrderedDict", "UserDict", "UserList", "UserString", "defaultdict", "deque", "namedtuple"]
_S = TypeVar("_S")
_T = TypeVar("_T")
_T1 = TypeVar("_T1")
_T2 = TypeVar("_T2")
_KT = TypeVar("_KT")
_VT = TypeVar("_VT")
_KT_co = TypeVar("_KT_co", covariant=True)
_VT_co = TypeVar("_VT_co", covariant=True)
def namedtuple(typename: str, field_names: str | Iterable[str], *, rename: bool = ..., module: str | None = ..., defaults: Iterable[Any] | None = ...) -> type[tuple[Any, ...]]:
    ...

class UserDict(MutableMapping[_KT, _VT]):
    data: dict[_KT, _VT]
    @overload
    def __init__(self, dict: None = ..., /) -> None:
        ...
    
    @overload
    def __init__(self: UserDict[str, _VT], dict: None = ..., /, **kwargs: _VT) -> None:
        ...
    
    @overload
    def __init__(self, dict: SupportsKeysAndGetItem[_KT, _VT], /) -> None:
        ...
    
    @overload
    def __init__(self: UserDict[str, _VT], dict: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> None:
        ...
    
    @overload
    def __init__(self, iterable: Iterable[tuple[_KT, _VT]], /) -> None:
        ...
    
    @overload
    def __init__(self: UserDict[str, _VT], iterable: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> None:
        ...
    
    @overload
    def __init__(self: UserDict[str, str], iterable: Iterable[list[str]], /) -> None:
        ...
    
    @overload
    def __init__(self: UserDict[bytes, bytes], iterable: Iterable[list[bytes]], /) -> None:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, key: _KT) -> _VT:
        ...
    
    def __setitem__(self, key: _KT, item: _VT) -> None:
        ...
    
    def __delitem__(self, key: _KT) -> None:
        ...
    
    def __iter__(self) -> Iterator[_KT]:
        ...
    
    def __contains__(self, key: object) -> bool:
        ...
    
    def copy(self) -> Self:
        ...
    
    def __copy__(self) -> Self:
        ...
    
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: None = ...) -> UserDict[_T, Any | None]:
        ...
    
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: _S) -> UserDict[_T, _S]:
        ...
    
    if sys.version_info >= (3, 9):
        @overload
        def __or__(self, other: UserDict[_KT, _VT] | dict[_KT, _VT]) -> Self:
            ...
        
        @overload
        def __or__(self, other: UserDict[_T1, _T2] | dict[_T1, _T2]) -> UserDict[_KT | _T1, _VT | _T2]:
            ...
        
        @overload
        def __ror__(self, other: UserDict[_KT, _VT] | dict[_KT, _VT]) -> Self:
            ...
        
        @overload
        def __ror__(self, other: UserDict[_T1, _T2] | dict[_T1, _T2]) -> UserDict[_KT | _T1, _VT | _T2]:
            ...
        
        @overload
        def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self:
            ...
        
        @overload
        def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self:
            ...
        
    if sys.version_info >= (3, 12):
        ...


class UserList(MutableSequence[_T]):
    data: list[_T]
    @overload
    def __init__(self, initlist: None = ...) -> None:
        ...
    
    @overload
    def __init__(self, initlist: Iterable[_T]) -> None:
        ...
    
    __hash__: ClassVar[None]
    def __lt__(self, other: list[_T] | UserList[_T]) -> bool:
        ...
    
    def __le__(self, other: list[_T] | UserList[_T]) -> bool:
        ...
    
    def __gt__(self, other: list[_T] | UserList[_T]) -> bool:
        ...
    
    def __ge__(self, other: list[_T] | UserList[_T]) -> bool:
        ...
    
    def __eq__(self, other: object) -> bool:
        ...
    
    def __contains__(self, item: object) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    @overload
    def __getitem__(self, i: SupportsIndex) -> _T:
        ...
    
    @overload
    def __getitem__(self, i: slice) -> Self:
        ...
    
    @overload
    def __setitem__(self, i: SupportsIndex, item: _T) -> None:
        ...
    
    @overload
    def __setitem__(self, i: slice, item: Iterable[_T]) -> None:
        ...
    
    def __delitem__(self, i: SupportsIndex | slice) -> None:
        ...
    
    def __add__(self, other: Iterable[_T]) -> Self:
        ...
    
    def __radd__(self, other: Iterable[_T]) -> Self:
        ...
    
    def __iadd__(self, other: Iterable[_T]) -> Self:
        ...
    
    def __mul__(self, n: int) -> Self:
        ...
    
    def __rmul__(self, n: int) -> Self:
        ...
    
    def __imul__(self, n: int) -> Self:
        ...
    
    def append(self, item: _T) -> None:
        ...
    
    def insert(self, i: int, item: _T) -> None:
        ...
    
    def pop(self, i: int = ...) -> _T:
        ...
    
    def remove(self, item: _T) -> None:
        ...
    
    def copy(self) -> Self:
        ...
    
    def __copy__(self) -> Self:
        ...
    
    def count(self, item: _T) -> int:
        ...
    
    def index(self, item: _T, start: SupportsIndex = ..., stop: SupportsIndex = ..., /) -> int:
        ...
    
    @overload
    def sort(self: UserList[SupportsRichComparisonT], *, key: None = ..., reverse: bool = ...) -> None:
        ...
    
    @overload
    def sort(self, *, key: Callable[[_T], SupportsRichComparison], reverse: bool = ...) -> None:
        ...
    
    def extend(self, other: Iterable[_T]) -> None:
        ...
    


class UserString(Sequence[UserString]):
    data: str
    def __init__(self, seq: object) -> None:
        ...
    
    def __int__(self) -> int:
        ...
    
    def __float__(self) -> float:
        ...
    
    def __complex__(self) -> complex:
        ...
    
    def __getnewargs__(self) -> tuple[str]:
        ...
    
    def __lt__(self, string: str | UserString) -> bool:
        ...
    
    def __le__(self, string: str | UserString) -> bool:
        ...
    
    def __gt__(self, string: str | UserString) -> bool:
        ...
    
    def __ge__(self, string: str | UserString) -> bool:
        ...
    
    def __eq__(self, string: object) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    
    def __contains__(self, char: object) -> bool:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __getitem__(self, index: SupportsIndex | slice) -> Self:
        ...
    
    def __iter__(self) -> Iterator[Self]:
        ...
    
    def __reversed__(self) -> Iterator[Self]:
        ...
    
    def __add__(self, other: object) -> Self:
        ...
    
    def __radd__(self, other: object) -> Self:
        ...
    
    def __mul__(self, n: int) -> Self:
        ...
    
    def __rmul__(self, n: int) -> Self:
        ...
    
    def __mod__(self, args: Any) -> Self:
        ...
    
    def __rmod__(self, template: object) -> Self:
        ...
    
    def capitalize(self) -> Self:
        ...
    
    def casefold(self) -> Self:
        ...
    
    def center(self, width: int, *args: Any) -> Self:
        ...
    
    def count(self, sub: str | UserString, start: int = ..., end: int = ...) -> int:
        ...
    
    def encode(self: UserString, encoding: str | None = ..., errors: str | None = ...) -> bytes:
        ...
    
    def endswith(self, suffix: str | tuple[str, ...], start: int | None = ..., end: int | None = ...) -> bool:
        ...
    
    def expandtabs(self, tabsize: int = ...) -> Self:
        ...
    
    def find(self, sub: str | UserString, start: int = ..., end: int = ...) -> int:
        ...
    
    def format(self, *args: Any, **kwds: Any) -> str:
        ...
    
    def format_map(self, mapping: Mapping[str, Any]) -> str:
        ...
    
    def index(self, sub: str, start: int = ..., end: int = ...) -> int:
        ...
    
    def isalpha(self) -> bool:
        ...
    
    def isalnum(self) -> bool:
        ...
    
    def isdecimal(self) -> bool:
        ...
    
    def isdigit(self) -> bool:
        ...
    
    def isidentifier(self) -> bool:
        ...
    
    def islower(self) -> bool:
        ...
    
    def isnumeric(self) -> bool:
        ...
    
    def isprintable(self) -> bool:
        ...
    
    def isspace(self) -> bool:
        ...
    
    def istitle(self) -> bool:
        ...
    
    def isupper(self) -> bool:
        ...
    
    def isascii(self) -> bool:
        ...
    
    def join(self, seq: Iterable[str]) -> str:
        ...
    
    def ljust(self, width: int, *args: Any) -> Self:
        ...
    
    def lower(self) -> Self:
        ...
    
    def lstrip(self, chars: str | None = ...) -> Self:
        ...
    
    maketrans = ...
    def partition(self, sep: str) -> tuple[str, str, str]:
        ...
    
    if sys.version_info >= (3, 9):
        def removeprefix(self, prefix: str | UserString, /) -> Self:
            ...
        
        def removesuffix(self, suffix: str | UserString, /) -> Self:
            ...
        
    def replace(self, old: str | UserString, new: str | UserString, maxsplit: int = ...) -> Self:
        ...
    
    def rfind(self, sub: str | UserString, start: int = ..., end: int = ...) -> int:
        ...
    
    def rindex(self, sub: str | UserString, start: int = ..., end: int = ...) -> int:
        ...
    
    def rjust(self, width: int, *args: Any) -> Self:
        ...
    
    def rpartition(self, sep: str) -> tuple[str, str, str]:
        ...
    
    def rstrip(self, chars: str | None = ...) -> Self:
        ...
    
    def split(self, sep: str | None = ..., maxsplit: int = ...) -> list[str]:
        ...
    
    def rsplit(self, sep: str | None = ..., maxsplit: int = ...) -> list[str]:
        ...
    
    def splitlines(self, keepends: bool = ...) -> list[str]:
        ...
    
    def startswith(self, prefix: str | tuple[str, ...], start: int | None = ..., end: int | None = ...) -> bool:
        ...
    
    def strip(self, chars: str | None = ...) -> Self:
        ...
    
    def swapcase(self) -> Self:
        ...
    
    def title(self) -> Self:
        ...
    
    def translate(self, *args: Any) -> Self:
        ...
    
    def upper(self) -> Self:
        ...
    
    def zfill(self, width: int) -> Self:
        ...
    


class deque(MutableSequence[_T]):
    @property
    def maxlen(self) -> int | None:
        ...
    
    @overload
    def __init__(self, *, maxlen: int | None = ...) -> None:
        ...
    
    @overload
    def __init__(self, iterable: Iterable[_T], maxlen: int | None = ...) -> None:
        ...
    
    def append(self, x: _T, /) -> None:
        ...
    
    def appendleft(self, x: _T, /) -> None:
        ...
    
    def copy(self) -> Self:
        ...
    
    def count(self, x: _T, /) -> int:
        ...
    
    def extend(self, iterable: Iterable[_T], /) -> None:
        ...
    
    def extendleft(self, iterable: Iterable[_T], /) -> None:
        ...
    
    def insert(self, i: int, x: _T, /) -> None:
        ...
    
    def index(self, x: _T, start: int = ..., stop: int = ..., /) -> int:
        ...
    
    def pop(self) -> _T:
        ...
    
    def popleft(self) -> _T:
        ...
    
    def remove(self, value: _T, /) -> None:
        ...
    
    def rotate(self, n: int = ..., /) -> None:
        ...
    
    def __copy__(self) -> Self:
        ...
    
    def __len__(self) -> int:
        ...
    
    __hash__: ClassVar[None]
    def __getitem__(self, key: SupportsIndex, /) -> _T:
        ...
    
    def __setitem__(self, key: SupportsIndex, value: _T, /) -> None:
        ...
    
    def __delitem__(self, key: SupportsIndex, /) -> None:
        ...
    
    def __contains__(self, key: object, /) -> bool:
        ...
    
    def __reduce__(self) -> tuple[type[Self], tuple[()], None, Iterator[_T]]:
        ...
    
    def __iadd__(self, value: Iterable[_T], /) -> Self:
        ...
    
    def __add__(self, value: Self, /) -> Self:
        ...
    
    def __mul__(self, value: int, /) -> Self:
        ...
    
    def __imul__(self, value: int, /) -> Self:
        ...
    
    def __lt__(self, value: deque[_T], /) -> bool:
        ...
    
    def __le__(self, value: deque[_T], /) -> bool:
        ...
    
    def __gt__(self, value: deque[_T], /) -> bool:
        ...
    
    def __ge__(self, value: deque[_T], /) -> bool:
        ...
    
    def __eq__(self, value: object, /) -> bool:
        ...
    
    if sys.version_info >= (3, 9):
        def __class_getitem__(cls, item: Any, /) -> GenericAlias:
            ...
        


class Counter(dict[_T, int], Generic[_T]):
    @overload
    def __init__(self, iterable: None = ..., /) -> None:
        ...
    
    @overload
    def __init__(self: Counter[str], iterable: None = ..., /, **kwargs: int) -> None:
        ...
    
    @overload
    def __init__(self, mapping: SupportsKeysAndGetItem[_T, int], /) -> None:
        ...
    
    @overload
    def __init__(self, iterable: Iterable[_T], /) -> None:
        ...
    
    def copy(self) -> Self:
        ...
    
    def elements(self) -> Iterator[_T]:
        ...
    
    def most_common(self, n: int | None = ...) -> list[tuple[_T, int]]:
        ...
    
    @classmethod
    def fromkeys(cls, iterable: Any, v: int | None = ...) -> NoReturn:
        ...
    
    @overload
    def subtract(self, iterable: None = ..., /) -> None:
        ...
    
    @overload
    def subtract(self, mapping: Mapping[_T, int], /) -> None:
        ...
    
    @overload
    def subtract(self, iterable: Iterable[_T], /) -> None:
        ...
    
    @overload
    def update(self, m: Mapping[_T, int], /, **kwargs: int) -> None:
        ...
    
    @overload
    def update(self, iterable: Iterable[_T], /, **kwargs: int) -> None:
        ...
    
    @overload
    def update(self, iterable: None = ..., /, **kwargs: int) -> None:
        ...
    
    def __missing__(self, key: _T) -> int:
        ...
    
    def __delitem__(self, elem: object) -> None:
        ...
    
    if sys.version_info >= (3, 10):
        def __eq__(self, other: object) -> bool:
            ...
        
        def __ne__(self, other: object) -> bool:
            ...
        
    def __add__(self, other: Counter[_S]) -> Counter[_T | _S]:
        ...
    
    def __sub__(self, other: Counter[_T]) -> Counter[_T]:
        ...
    
    def __and__(self, other: Counter[_T]) -> Counter[_T]:
        ...
    
    def __or__(self, other: Counter[_S]) -> Counter[_T | _S]:
        ...
    
    def __pos__(self) -> Counter[_T]:
        ...
    
    def __neg__(self) -> Counter[_T]:
        ...
    
    def __iadd__(self, other: SupportsItems[_T, int]) -> Self:
        ...
    
    def __isub__(self, other: SupportsItems[_T, int]) -> Self:
        ...
    
    def __iand__(self, other: SupportsItems[_T, int]) -> Self:
        ...
    
    def __ior__(self, other: SupportsItems[_T, int]) -> Self:
        ...
    
    if sys.version_info >= (3, 10):
        def total(self) -> int:
            ...
        
        def __le__(self, other: Counter[Any]) -> bool:
            ...
        
        def __lt__(self, other: Counter[Any]) -> bool:
            ...
        
        def __ge__(self, other: Counter[Any]) -> bool:
            ...
        
        def __gt__(self, other: Counter[Any]) -> bool:
            ...
        


class _OrderedDictKeysView(KeysView[_KT_co]):
    def __reversed__(self) -> Iterator[_KT_co]:
        ...
    


class _OrderedDictItemsView(ItemsView[_KT_co, _VT_co]):
    def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]:
        ...
    


class _OrderedDictValuesView(ValuesView[_VT_co]):
    def __reversed__(self) -> Iterator[_VT_co]:
        ...
    


@final
class _odict_keys(dict_keys[_KT_co, _VT_co]):
    def __reversed__(self) -> Iterator[_KT_co]:
        ...
    


@final
class _odict_items(dict_items[_KT_co, _VT_co]):
    def __reversed__(self) -> Iterator[tuple[_KT_co, _VT_co]]:
        ...
    


@final
class _odict_values(dict_values[_KT_co, _VT_co]):
    def __reversed__(self) -> Iterator[_VT_co]:
        ...
    


class OrderedDict(dict[_KT, _VT]):
    def popitem(self, last: bool = ...) -> tuple[_KT, _VT]:
        ...
    
    def move_to_end(self, key: _KT, last: bool = ...) -> None:
        ...
    
    def copy(self) -> Self:
        ...
    
    def __reversed__(self) -> Iterator[_KT]:
        ...
    
    def keys(self) -> _odict_keys[_KT, _VT]:
        ...
    
    def items(self) -> _odict_items[_KT, _VT]:
        ...
    
    def values(self) -> _odict_values[_KT, _VT]:
        ...
    
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: None = ...) -> OrderedDict[_T, Any | None]:
        ...
    
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: _S) -> OrderedDict[_T, _S]:
        ...
    
    @overload
    def setdefault(self: OrderedDict[_KT, _T | None], key: _KT, default: None = ...) -> _T | None:
        ...
    
    @overload
    def setdefault(self, key: _KT, default: _VT) -> _VT:
        ...
    
    @overload
    def pop(self, key: _KT) -> _VT:
        ...
    
    @overload
    def pop(self, key: _KT, default: _VT) -> _VT:
        ...
    
    @overload
    def pop(self, key: _KT, default: _T) -> _VT | _T:
        ...
    
    def __eq__(self, value: object, /) -> bool:
        ...
    
    if sys.version_info >= (3, 9):
        @overload
        def __or__(self, value: dict[_KT, _VT], /) -> Self:
            ...
        
        @overload
        def __or__(self, value: dict[_T1, _T2], /) -> OrderedDict[_KT | _T1, _VT | _T2]:
            ...
        
        @overload
        def __ror__(self, value: dict[_KT, _VT], /) -> Self:
            ...
        
        @overload
        def __ror__(self, value: dict[_T1, _T2], /) -> OrderedDict[_KT | _T1, _VT | _T2]:
            ...
        


class defaultdict(dict[_KT, _VT]):
    default_factory: Callable[[], _VT] | None
    @overload
    def __init__(self) -> None:
        ...
    
    @overload
    def __init__(self: defaultdict[str, _VT], **kwargs: _VT) -> None:
        ...
    
    @overload
    def __init__(self, default_factory: Callable[[], _VT] | None, /) -> None:
        ...
    
    @overload
    def __init__(self: defaultdict[str, _VT], default_factory: Callable[[], _VT] | None, /, **kwargs: _VT) -> None:
        ...
    
    @overload
    def __init__(self, default_factory: Callable[[], _VT] | None, map: SupportsKeysAndGetItem[_KT, _VT], /) -> None:
        ...
    
    @overload
    def __init__(self: defaultdict[str, _VT], default_factory: Callable[[], _VT] | None, map: SupportsKeysAndGetItem[str, _VT], /, **kwargs: _VT) -> None:
        ...
    
    @overload
    def __init__(self, default_factory: Callable[[], _VT] | None, iterable: Iterable[tuple[_KT, _VT]], /) -> None:
        ...
    
    @overload
    def __init__(self: defaultdict[str, _VT], default_factory: Callable[[], _VT] | None, iterable: Iterable[tuple[str, _VT]], /, **kwargs: _VT) -> None:
        ...
    
    def __missing__(self, key: _KT, /) -> _VT:
        ...
    
    def __copy__(self) -> Self:
        ...
    
    def copy(self) -> Self:
        ...
    
    if sys.version_info >= (3, 9):
        @overload
        def __or__(self, value: dict[_KT, _VT], /) -> Self:
            ...
        
        @overload
        def __or__(self, value: dict[_T1, _T2], /) -> defaultdict[_KT | _T1, _VT | _T2]:
            ...
        
        @overload
        def __ror__(self, value: dict[_KT, _VT], /) -> Self:
            ...
        
        @overload
        def __ror__(self, value: dict[_T1, _T2], /) -> defaultdict[_KT | _T1, _VT | _T2]:
            ...
        


class ChainMap(MutableMapping[_KT, _VT]):
    maps: list[MutableMapping[_KT, _VT]]
    def __init__(self, *maps: MutableMapping[_KT, _VT]) -> None:
        ...
    
    def new_child(self, m: MutableMapping[_KT, _VT] | None = ...) -> Self:
        ...
    
    @property
    def parents(self) -> Self:
        ...
    
    def __setitem__(self, key: _KT, value: _VT) -> None:
        ...
    
    def __delitem__(self, key: _KT) -> None:
        ...
    
    def __getitem__(self, key: _KT) -> _VT:
        ...
    
    def __iter__(self) -> Iterator[_KT]:
        ...
    
    def __len__(self) -> int:
        ...
    
    def __contains__(self, key: object) -> bool:
        ...
    
    @overload
    def get(self, key: _KT, default: None = ...) -> _VT | None:
        ...
    
    @overload
    def get(self, key: _KT, default: _T) -> _VT | _T:
        ...
    
    def __missing__(self, key: _KT) -> _VT:
        ...
    
    def __bool__(self) -> bool:
        ...
    
    @overload
    def setdefault(self: ChainMap[_KT, _T | None], key: _KT, default: None = ...) -> _T | None:
        ...
    
    @overload
    def setdefault(self, key: _KT, default: _VT) -> _VT:
        ...
    
    @overload
    def pop(self, key: _KT) -> _VT:
        ...
    
    @overload
    def pop(self, key: _KT, default: _VT) -> _VT:
        ...
    
    @overload
    def pop(self, key: _KT, default: _T) -> _VT | _T:
        ...
    
    def copy(self) -> Self:
        ...
    
    __copy__ = ...
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T]) -> ChainMap[_T, Any | None]:
        ...
    
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: None, /) -> ChainMap[_T, Any | None]:
        ...
    
    @classmethod
    @overload
    def fromkeys(cls, iterable: Iterable[_T], value: _S, /) -> ChainMap[_T, _S]:
        ...
    
    if sys.version_info >= (3, 9):
        @overload
        def __or__(self, other: Mapping[_KT, _VT]) -> Self:
            ...
        
        @overload
        def __or__(self, other: Mapping[_T1, _T2]) -> ChainMap[_KT | _T1, _VT | _T2]:
            ...
        
        @overload
        def __ror__(self, other: Mapping[_KT, _VT]) -> Self:
            ...
        
        @overload
        def __ror__(self, other: Mapping[_T1, _T2]) -> ChainMap[_KT | _T1, _VT | _T2]:
            ...
        
        @overload
        def __ior__(self, other: SupportsKeysAndGetItem[_KT, _VT]) -> Self:
            ...
        
        @overload
        def __ior__(self, other: Iterable[tuple[_KT, _VT]]) -> Self:
            ...
        


