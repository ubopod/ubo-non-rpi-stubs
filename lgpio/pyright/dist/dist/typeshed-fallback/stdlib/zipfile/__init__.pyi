"""
This type stub file was generated by pyright.
"""

import io
import sys
from _typeshed import SizedBuffer, StrOrBytesPath, StrPath
from collections.abc import Callable, Iterable, Iterator
from io import TextIOWrapper
from os import PathLike
from types import TracebackType
from typing import Final, IO, Literal, Protocol, overload
from typing_extensions import Self, TypeAlias

__all__ = ["BadZipFile", "BadZipfile", "Path", "error", "ZIP_STORED", "ZIP_DEFLATED", "ZIP_BZIP2", "ZIP_LZMA", "is_zipfile", "ZipInfo", "ZipFile", "PyZipFile", "LargeZipFile"]
_DateTuple = tuple[int, int, int, int, int, int]
_ZipFileMode = Literal["r", "w", "x", "a"]
_ReadWriteMode: TypeAlias = Literal["r", "w"]
_ReadWriteBinaryMode: TypeAlias = Literal["r", "w", "rb", "wb"]
class BadZipFile(Exception):
    ...


BadZipfile = BadZipFile
error = BadZipfile
class LargeZipFile(Exception):
    ...


class _ZipStream(Protocol):
    def read(self, n: int, /) -> bytes:
        ...
    


class _SupportsReadSeekTell(Protocol):
    def read(self, n: int = ..., /) -> bytes:
        ...
    
    def seek(self, cookie: int, whence: int, /) -> object:
        ...
    
    def tell(self) -> int:
        ...
    


class _ClosableZipStream(_ZipStream, Protocol):
    def close(self) -> object:
        ...
    


class ZipExtFile(io.BufferedIOBase):
    MAX_N: int
    MIN_READ_SIZE: int
    MAX_SEEK_READ: int
    newlines: list[bytes] | None
    mode: _ReadWriteMode
    name: str
    @overload
    def __init__(self, fileobj: _ClosableZipStream, mode: _ReadWriteMode, zipinfo: ZipInfo, pwd: bytes | None, close_fileobj: Literal[True]) -> None:
        ...
    
    @overload
    def __init__(self, fileobj: _ClosableZipStream, mode: _ReadWriteMode, zipinfo: ZipInfo, pwd: bytes | None = ..., *, close_fileobj: Literal[True]) -> None:
        ...
    
    @overload
    def __init__(self, fileobj: _ZipStream, mode: _ReadWriteMode, zipinfo: ZipInfo, pwd: bytes | None = ..., close_fileobj: Literal[False] = ...) -> None:
        ...
    
    def read(self, n: int | None = ...) -> bytes:
        ...
    
    def readline(self, limit: int = ...) -> bytes:
        ...
    
    def peek(self, n: int = ...) -> bytes:
        ...
    
    def read1(self, n: int | None) -> bytes:
        ...
    
    def seek(self, offset: int, whence: int = ...) -> int:
        ...
    


class _Writer(Protocol):
    def write(self, s: str, /) -> object:
        ...
    


class _ZipReadable(Protocol):
    def seek(self, offset: int, whence: int = ..., /) -> int:
        ...
    
    def read(self, n: int = ..., /) -> bytes:
        ...
    


class _ZipTellable(Protocol):
    def tell(self) -> int:
        ...
    


class _ZipReadableTellable(_ZipReadable, _ZipTellable, Protocol):
    ...


class _ZipWritable(Protocol):
    def flush(self) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def write(self, b: bytes, /) -> int:
        ...
    


class ZipFile:
    filename: str | None
    debug: int
    comment: bytes
    filelist: list[ZipInfo]
    fp: IO[bytes] | None
    NameToInfo: dict[str, ZipInfo]
    start_dir: int
    compression: int
    compresslevel: int | None
    mode: _ZipFileMode
    pwd: bytes | None
    if sys.version_info >= (3, 11):
        @overload
        def __init__(self, file: StrPath | IO[bytes], mode: _ZipFileMode = ..., compression: int = ..., allowZip64: bool = ..., compresslevel: int | None = ..., *, strict_timestamps: bool = ..., metadata_encoding: str | None = ...) -> None:
            ...
        
        @overload
        def __init__(self, file: StrPath | _ZipReadable, mode: Literal["r"] = ..., compression: int = ..., allowZip64: bool = ..., compresslevel: int | None = ..., *, strict_timestamps: bool = ..., metadata_encoding: str | None = ...) -> None:
            ...
        
        @overload
        def __init__(self, file: StrPath | _ZipWritable, mode: Literal["w", "x"] = ..., compression: int = ..., allowZip64: bool = ..., compresslevel: int | None = ..., *, strict_timestamps: bool = ..., metadata_encoding: None = ...) -> None:
            ...
        
        @overload
        def __init__(self, file: StrPath | _ZipReadableTellable, mode: Literal["a"] = ..., compression: int = ..., allowZip64: bool = ..., compresslevel: int | None = ..., *, strict_timestamps: bool = ..., metadata_encoding: None = ...) -> None:
            ...
        
    else:
        ...
    def __enter__(self) -> Self:
        ...
    
    def __exit__(self, type: type[BaseException] | None, value: BaseException | None, traceback: TracebackType | None) -> None:
        ...
    
    def close(self) -> None:
        ...
    
    def getinfo(self, name: str) -> ZipInfo:
        ...
    
    def infolist(self) -> list[ZipInfo]:
        ...
    
    def namelist(self) -> list[str]:
        ...
    
    def open(self, name: str | ZipInfo, mode: _ReadWriteMode = ..., pwd: bytes | None = ..., *, force_zip64: bool = ...) -> IO[bytes]:
        ...
    
    def extract(self, member: str | ZipInfo, path: StrPath | None = ..., pwd: bytes | None = ...) -> str:
        ...
    
    def extractall(self, path: StrPath | None = ..., members: Iterable[str | ZipInfo] | None = ..., pwd: bytes | None = ...) -> None:
        ...
    
    def printdir(self, file: _Writer | None = ...) -> None:
        ...
    
    def setpassword(self, pwd: bytes) -> None:
        ...
    
    def read(self, name: str | ZipInfo, pwd: bytes | None = ...) -> bytes:
        ...
    
    def testzip(self) -> str | None:
        ...
    
    def write(self, filename: StrPath, arcname: StrPath | None = ..., compress_type: int | None = ..., compresslevel: int | None = ...) -> None:
        ...
    
    def writestr(self, zinfo_or_arcname: str | ZipInfo, data: SizedBuffer | str, compress_type: int | None = ..., compresslevel: int | None = ...) -> None:
        ...
    
    if sys.version_info >= (3, 11):
        def mkdir(self, zinfo_or_directory_name: str | ZipInfo, mode: int = ...) -> None:
            ...
        
    def __del__(self) -> None:
        ...
    


class PyZipFile(ZipFile):
    def __init__(self, file: str | IO[bytes], mode: _ZipFileMode = ..., compression: int = ..., allowZip64: bool = ..., optimize: int = ...) -> None:
        ...
    
    def writepy(self, pathname: str, basename: str = ..., filterfunc: Callable[[str], bool] | None = ...) -> None:
        ...
    


class ZipInfo:
    filename: str
    date_time: _DateTuple
    compress_type: int
    comment: bytes
    extra: bytes
    create_system: int
    create_version: int
    extract_version: int
    reserved: int
    flag_bits: int
    volume: int
    internal_attr: int
    external_attr: int
    header_offset: int
    CRC: int
    compress_size: int
    file_size: int
    orig_filename: str
    if sys.version_info >= (3, 13):
        ...
    def __init__(self, filename: str = ..., date_time: _DateTuple = ...) -> None:
        ...
    
    @classmethod
    def from_file(cls, filename: StrPath, arcname: StrPath | None = ..., *, strict_timestamps: bool = ...) -> Self:
        ...
    
    def is_dir(self) -> bool:
        ...
    
    def FileHeader(self, zip64: bool | None = ...) -> bytes:
        ...
    


if sys.version_info >= (3, 12):
    ...
else:
    class CompleteDirs(ZipFile):
        def resolve_dir(self, name: str) -> str:
            ...
        
        @overload
        @classmethod
        def make(cls, source: ZipFile) -> CompleteDirs:
            ...
        
        @overload
        @classmethod
        def make(cls, source: StrPath | IO[bytes]) -> Self:
            ...
        
    
    
    class Path:
        root: CompleteDirs
        at: str
        def __init__(self, root: ZipFile | StrPath | IO[bytes], at: str = ...) -> None:
            ...
        
        @property
        def name(self) -> str:
            ...
        
        @property
        def parent(self) -> PathLike[str]:
            ...
        
        def is_dir(self) -> bool:
            ...
        
        def is_file(self) -> bool:
            ...
        
        def exists(self) -> bool:
            ...
        
        def read_text(self, encoding: str | None = ..., errors: str | None = ..., newline: str | None = ..., line_buffering: bool = ..., write_through: bool = ...) -> str:
            ...
        
        def read_bytes(self) -> bytes:
            ...
        
        def __truediv__(self, add: StrPath) -> Path:
            ...
        
    
    
def is_zipfile(filename: StrOrBytesPath | _SupportsReadSeekTell) -> bool:
    ...

ZIP_STORED: Final[int]
ZIP_DEFLATED: Final[int]
ZIP64_LIMIT: Final[int]
ZIP_FILECOUNT_LIMIT: Final[int]
ZIP_MAX_COMMENT: Final[int]
ZIP_BZIP2: Final[int]
ZIP_LZMA: Final[int]
