"""
This type stub file was generated by pyright.
"""

import numpy as np
from enum import Enum
from typing import Any, Dict, List, Tuple
from PIL import Image
from picamera2.encoders import Encoder
from .configuration import CameraConfiguration

"""picamera2 main class"""
STILL = ...
RAW = ...
VIDEO = ...
VIEWFINDER = ...
_log = ...
class Preview(Enum):
    """Enum that applications can pass to the start_preview method."""
    NULL = ...
    DRM = ...
    QT = ...
    QTGL = ...


class CameraManager:
    def __init__(self) -> None:
        ...
    
    def setup(self): # -> None:
        ...
    
    def add(self, index, camera): # -> None:
        ...
    
    def cleanup(self, index): # -> None:
        ...
    
    def listen(self): # -> None:
        ...
    
    def handle_request(self, flushid=...): # -> None:
        """Handle requests

        :param cameras: Dictionary of Picamera2
        :type cameras: dict
        """
        ...
    


class Picamera2:
    """Welcome to the PiCamera2 class."""
    platform = ...
    DEBUG = ...
    INFO = ...
    WARNING = ...
    ERROR = ...
    CRITICAL = ...
    _cm = ...
    @staticmethod
    def set_logging(level=..., output=..., msg=...): # -> None:
        """Configure logging for simple standalone use cases.

        For example:
        Picamera2.set_logging(Picamera2.INFO)
        Picamera2.set_logging(level=Picamera2.DEBUG, msg="%(levelname)s: %(message)s")

        :param level: A logging level
        :type level: int
        :param output: An output stream for the messages
        :type output: file-like object
        :param msg: Logging message format
        :type msg: str
        """
        ...
    
    @staticmethod
    def load_tuning_file(tuning_file, dir=...): # -> Any:
        """Load the named tuning file.

        If dir is given, then only that directory is checked,
        otherwise a list of likely installation directories is searched

        :param tuning_file: Tuning file
        :type tuning_file: str
        :param dir: Directory of tuning file, defaults to None
        :type dir: str, optional
        :raises RuntimeError: Produced if tuning file not found
        :return: Dictionary of tuning file
        :rtype: dict
        """
        ...
    
    @staticmethod
    def find_tuning_algo(tuning: dict, name: str) -> dict:
        """
        Return the parameters for the named algorithm in the given camera tuning.

        :param tuning: The camera tuning object
        :type tuning: dict
        :param name: The name of the algorithm
        :type name: str
        :rtype: dict
        """
        ...
    
    @staticmethod
    def global_camera_info() -> list:
        """Return Id string and Model name for all attached cameras, one dict per camera.

        Ordered correctly by camera number. Also return the location and rotation
        of the camera when known, as these may help distinguish which is which.
        """
        ...
    
    def __init__(self, camera_num=..., verbose_console=..., tuning=..., allocator=...) -> None:
        """Initialise camera system and open the camera for use.

        :param camera_num: Camera index, defaults to 0
        :type camera_num: int, optional
        :param verbose_console: Unused
        :type verbose_console: int, optional
        :param tuning: Tuning filename, defaults to None
        :type tuning: str, optional
        :raises RuntimeError: Init didn't complete
        """
        ...
    
    @property
    def camera_manager(self): # -> None:
        ...
    
    @property
    def preview_configuration(self) -> CameraConfiguration:
        ...
    
    @preview_configuration.setter
    def preview_configuration(self, value): # -> None:
        ...
    
    @property
    def still_configuration(self) -> CameraConfiguration:
        ...
    
    @still_configuration.setter
    def still_configuration(self, value): # -> None:
        ...
    
    @property
    def video_configuration(self) -> CameraConfiguration:
        ...
    
    @video_configuration.setter
    def video_configuration(self, value): # -> None:
        ...
    
    @property
    def request_callback(self): # -> None:
        """Now Deprecated"""
        ...
    
    @request_callback.setter
    def request_callback(self, value): # -> None:
        """Now Deprecated"""
        ...
    
    @property
    def camera_properties(self) -> dict:
        """Camera properties

        :return: Camera properties
        :rtype: dict
        """
        ...
    
    @property
    def camera_controls(self) -> dict:
        ...
    
    @property
    def title_fields(self): # -> None:
        """The metadata fields reported in the title bar of any preview window."""
        ...
    
    @title_fields.setter
    def title_fields(self, fields): # -> None:
        ...
    
    def __enter__(self): # -> Self:
        """Used for allowing use with context manager

        :return: self
        :rtype: Picamera2
        """
        ...
    
    def __exit__(self, exc_type, exc_val, exc_traceback): # -> None:
        """Used for allowing use with context manager

        :param exc_type: Exception type
        :type exc_type: Type[BaseException]
        :param exc_val: Exception
        :type exc_val: BaseException
        :param exc_traceback: Traceback
        :type exc_traceback: TracebackType
        """
        ...
    
    def __del__(self): # -> None:
        """Without this libcamera will complain if we shut down without closing the camera."""
        ...
    
    @property
    def sensor_modes(self) -> list:
        """The available sensor modes

        When called for the first time this will reconfigure the camera
        in order to read the modes.
        """
        ...
    
    def attach_preview(self, preview) -> None:
        ...
    
    def start_preview(self, preview=..., **kwargs) -> None:
        """
        Start the given preview which drives the camera processing.

        The preview may be either:
          None or False - in which case a NullPreview is made,
          True - which we hope in future to use to autodetect
          a Preview enum value - in which case a preview of that type is made,
          or an actual preview object.

        When using the enum form, extra keyword arguments can be supplied that
        will be forwarded to the preview class constructor.
        """
        ...
    
    def detach_preview(self) -> None:
        ...
    
    def stop_preview(self) -> None:
        """Stop preview

        :raises RuntimeError: Unable to stop preview
        """
        ...
    
    def close(self) -> None:
        """Close camera

        :raises RuntimeError: Closing failed
        """
        ...
    
    _raw_stream_ignore_list = ...
    def create_preview_configuration(self, main=..., lores=..., raw=..., transform=..., colour_space=..., buffer_count=..., controls=..., display=..., encode=..., queue=..., sensor=..., use_case=...) -> dict:
        """Make a configuration suitable for camera preview."""
        ...
    
    def create_still_configuration(self, main=..., lores=..., raw=..., transform=..., colour_space=..., buffer_count=..., controls=..., display=..., encode=..., queue=..., sensor=..., use_case=...) -> dict:
        """Make a configuration suitable for still image capture. Default to 2 buffers, as the Gl preview would need them."""
        ...
    
    def create_video_configuration(self, main=..., lores=..., raw=..., transform=..., colour_space=..., buffer_count=..., controls=..., display=..., encode=..., queue=..., sensor=..., use_case=...) -> dict:
        """Make a configuration suitable for video recording."""
        ...
    
    def check_stream_config(self, stream_config, name) -> None:
        """Check the configuration of the passed in config.

        Raises RuntimeError if the configuration is invalid.
        """
        ...
    
    def check_camera_config(self, camera_config: dict) -> None:
        ...
    
    @staticmethod
    def align_stream(stream_config: dict, optimal=...) -> None:
        ...
    
    @staticmethod
    def align_configuration(config: dict, optimal=...) -> None:
        ...
    
    def configure_(self, camera_config=...) -> None:
        """Configure the camera system with the given configuration.

        :param camera_config: Configuration, defaults to the 'preview' configuration
        :type camera_config: dict, string or CameraConfiguration, optional
        :raises RuntimeError: Failed to configure
        """
        ...
    
    def configure(self, camera_config=...) -> None:
        """Configure the camera system with the given configuration."""
        ...
    
    def camera_configuration(self) -> dict:
        """Return the camera configuration."""
        ...
    
    def stream_configuration(self, name=...) -> dict:
        """Return the stream configuration for the named stream."""
        ...
    
    def start_(self) -> None:
        """Start the camera system running."""
        ...
    
    def start(self, config=..., show_preview=...) -> None:
        """
        Start the camera system running.

        Camera controls may be sent to the camera before it starts running.

        The following parameters may be supplied:

        config - if not None this is used to configure the camera. This is just a
            convenience so that you don't have to call configure explicitly.

        show_preview - whether to show a preview window. You can pass in the preview
            type or True to attempt to autodetect. If left as False you'll get no
            visible preview window but the "NULL preview" will still be run. The
            value None would mean no event loop runs at all and you would have to
            implement your own.
        """
        ...
    
    def stop_(self, request=...) -> None:
        """Stop the camera.

        Only call this function directly from within the camera event
        loop, such as in a Qt application.
        """
        ...
    
    def stop(self) -> None:
        """Stop the camera."""
        ...
    
    def set_controls(self, controls) -> None:
        """Set camera controls. These will be delivered with the next request that gets submitted."""
        ...
    
    def process_requests(self, display) -> None:
        ...
    
    def wait(self, job, timeout=...):
        """Wait for the given job to finish (if necessary) and return its final result.

        The job is obtained either by calling one of the Picamera2 methods asynchronously
        (passing wait=False), or as a parameter to the signal_function that can be
        supplied to those same methods.
        """
        ...
    
    def dispatch_functions(self, functions, wait, signal_function=..., immediate=...) -> None:
        """The main thread should use this to dispatch a number of operations for the event loop to perform.

        When there are multiple items each will be processed on a separate
        trip round the event loop, meaning that a single operation could stop and restart the
        camera and the next operation would receive a request from after the restart.
        """
        ...
    
    def set_frame_drops_(self, num_frames): # -> tuple[Literal[True], None]:
        """Only for use within the camera event loop before calling drop_frames_."""
        ...
    
    def drop_frames_(self): # -> tuple[Literal[True], None] | tuple[Literal[False], None]:
        ...
    
    def wait_for_timestamp_(self, timestamp_ns): # -> tuple[Literal[True], None] | tuple[Literal[False], None]:
        ...
    
    def drop_frames(self, num_frames, wait=..., signal_function=...): # -> None:
        """Drop num_frames frames from the camera."""
        ...
    
    def capture_file_(self, file_output, name: str, format=..., exif_data=...) -> dict:
        ...
    
    def capture_file(self, file_output, name: str = ..., format=..., wait=..., signal_function=..., exif_data=...) -> dict:
        """Capture an image to a file in the current camera mode.

        Return the metadata for the frame captured.

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    def switch_mode_(self, camera_config): # -> tuple[Literal[True], dict[Any, Any] | Any | str | None]:
        ...
    
    def switch_mode(self, camera_config, wait=..., signal_function=...): # -> None:
        """Switch the camera into another mode given by the camera_config."""
        ...
    
    def switch_mode_and_drop_frames(self, camera_config, num_frames, wait=..., signal_function=...): # -> None:
        """Switch the camera into the mode given by camera_config and drop the first num_frames frames."""
        ...
    
    def switch_mode_and_capture_file(self, camera_config, file_output, name=..., format=..., wait=..., signal_function=..., exif_data=..., delay=...): # -> None:
        """Switch the camera into a new (capture) mode, capture an image to file.

        Then return back to the initial camera mode.

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    def switch_mode_and_capture_request(self, camera_config, wait=..., signal_function=..., delay=...): # -> None:
        """Switch the camera into a new (capture) mode and capture a request, then switch back.

        Applications should use this with care because it may increase the risk of CMA heap
        fragmentation. It may be preferable to use switch_mode_capture_request_and_stop and to
        release the request before restarting the original camera mode.
        """
        ...
    
    def capture_request_(self): # -> tuple[Literal[False], None] | tuple[Literal[True], CompletedRequest]:
        ...
    
    def capture_request(self, wait=..., signal_function=..., flush=...): # -> None:
        """Fetch the next completed request from the camera system.

        You will be holding a reference to this request so you must release it again to return it
        to the camera system.
        """
        ...
    
    def switch_mode_capture_request_and_stop(self, camera_config, wait=..., signal_function=...): # -> None:
        """Switch the camera into a new (capture) mode, capture a request in the new mode and then stop the camera."""
        ...
    
    def capture_metadata_(self): # -> tuple[Literal[False], None] | tuple[Literal[True], dict[Any, Any]]:
        ...
    
    def capture_metadata(self, wait=..., signal_function=...): # -> None:
        """Fetch the metadata from the next camera frame."""
        ...
    
    def capture_buffer_(self, name): # -> tuple[Literal[False], None] | tuple[Literal[True], NDArray[unsignedinteger[_8Bit]]]:
        ...
    
    def capture_buffer(self, name=..., wait=..., signal_function=...): # -> None:
        """Make a 1d numpy array from the next frame in the named stream."""
        ...
    
    def capture_buffers_and_metadata_(self, names) -> Tuple[List[np.ndarray], dict]:
        ...
    
    def capture_buffers(self, names=..., wait=..., signal_function=...): # -> None:
        """Make a 1d numpy array from the next frame for each of the named streams."""
        ...
    
    def switch_mode_and_capture_buffer(self, camera_config, name=..., wait=..., signal_function=..., delay=...): # -> None:
        """Switch the camera into a new (capture) mode, capture the first buffer.

        Then return back to the initial camera mode.
        """
        ...
    
    def switch_mode_and_capture_buffers(self, camera_config, names=..., wait=..., signal_function=..., delay=...): # -> None:
        """Switch the camera into a new (capture) mode, capture the first buffers.

        Then return back to the initial camera mode.
        """
        ...
    
    def capture_array_(self, name): # -> tuple[Literal[False], None] | tuple[Literal[True], Any]:
        ...
    
    def capture_array(self, name=..., wait=..., signal_function=...): # -> None:
        """Make a 2d image from the next frame in the named stream."""
        ...
    
    def capture_arrays_and_metadata_(self, names) -> Tuple[List[np.ndarray], Dict[str, Any]]:
        ...
    
    def capture_arrays(self, names=..., wait=..., signal_function=...): # -> None:
        """Make 2d image arrays from the next frames in the named streams."""
        ...
    
    def switch_mode_and_capture_array(self, camera_config, name=..., wait=..., signal_function=..., delay=...): # -> None:
        """Switch the camera into a new (capture) mode, capture the image array data.

        Then return back to the initial camera mode.
        """
        ...
    
    def switch_mode_and_capture_arrays(self, camera_config, names=..., wait=..., signal_function=..., delay=...): # -> None:
        """Switch the camera into a new (capture) mode, capture the image arrays.

        Then return back to the initial camera mode.
        """
        ...
    
    def capture_image_(self, name: str) -> Image:
        """Capture image

        :param name: Stream name
        :type name: str
        """
        ...
    
    def capture_image(self, name: str = ..., wait: bool = ..., signal_function=...) -> Image:
        """Make a PIL image from the next frame in the named stream.

        :param name: Stream name, defaults to "main"
        :type name: str, optional
        :param wait: Wait for the event loop to finish an operation and signal us, defaults to True
        :type wait: bool, optional
        :param signal_function: Callback, defaults to None
        :type signal_function: function, optional
        :return: PIL Image
        :rtype: Image
        """
        ...
    
    def switch_mode_and_capture_image(self, camera_config, name: str = ..., wait: bool = ..., signal_function=..., delay=...) -> Image:
        """Switch the camera into a new (capture) mode, capture the image.

        Then return back to the initial camera mode.
        """
        ...
    
    def start_encoder(self, encoder=..., output=..., pts=..., quality=..., name=...) -> None:
        """Start encoder

        :param encoder: Sets encoder or uses existing, defaults to None
        :type encoder: Encoder, optional
        :raises RuntimeError: No encoder set or no stream
        """
        ...
    
    def stop_encoder(self, encoders=...) -> None:
        """Stops the encoder"""
        ...
    
    @property
    def encoders(self) -> set[Encoder]:
        """Extract current Encoder objects

        :return: Set of encoders
        :rtype: set
        """
        ...
    
    @encoders.setter
    def encoders(self, value): # -> None:
        """Set Encoder to be used

        :param value: Encoder to be set
        :type value: Encoder
        :raises RuntimeError: Fail to pass Encoder
        """
        ...
    
    def start_recording(self, encoder, output, pts=..., config=..., quality=..., name=...) -> None:
        """Start recording a video using the given encoder and to the given output.

        Output may be a string in which case the correspondingly named file is opened.

        :param encoder: Video encoder
        :type encoder: Encoder
        :param output: FileOutput object
        :type output: FileOutput
        """
        ...
    
    def stop_recording(self) -> None:
        """Stop recording a video. The encode and output are stopped and closed."""
        ...
    
    def set_overlay(self, overlay) -> None:
        """Display an overlay on the camera image.

        The overlay may be either None, in which case any overlay is removed,
        or a 4-channel ``ndarray``, the last of thechannels being taken as the alpha channel.

        :param overlay: Overlay or None
        :type overlay: ndarray
        :raises RuntimeError: Must pass a 4-channel image
        """
        ...
    
    def start_and_capture_files(self, name: str = ..., initial_delay=..., preview_mode=..., capture_mode=..., num_files=..., delay=..., show_preview=..., exif_data=...): # -> None:
        """This function makes capturing multiple images more convenient.

        Should only be used in command line line applications (not from a Qt application, for example).
        If will configure the camera as requested and start it, switching between preview and still modes
        for capture. It supports the following parameters (all optional):

        name - name of the files to which to save the images. If more than one image is to be
            captured then it should feature a format directive that will be replaced by a counter.

        initial_delay - any time delay (in seconds) before the first image is captured. The camera
            will run in preview mode during this period. The default time is 1s.

        preview_mode - the camera mode to use for the preview phase (defaulting to the
            Picamera2 object's preview_configuration field).

        capture_mode - the camera mode to use to capture the still images (defaulting to the
            Picamera2 object's still_configuration field).

        num_files - number of files to capture (default 1).

        delay - the time delay for every capture after the first (default 1s).

        show_preview - whether to show a preview window (default: yes). The preview window only
            displays an image by default during the preview phase, so if captures are back-to-back
            with delay zero, then there may be no images shown. This parameter only has any
            effect if a preview is not already running. If it is, it would have to be stopped first
            (with the stop_preview method).

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    def start_and_capture_file(self, name=..., delay=..., preview_mode=..., capture_mode=..., show_preview=..., exif_data=...): # -> None:
        """This function makes capturing a single image more convenient.

        Should only be used in command line line applications (not from a Qt application, for example).
        If will configure the camera as requested and start it, switching from the preview to the still
        mode for capture. It supports the following parameters (all optional):

        name - name of the file to which to save the images.

        delay - any time delay (in seconds) before the image is captured. The camera
            will run in preview mode during this period. The default time is 1s.

        preview_mode - the camera mode to use for the preview phase (defaulting to the
            Picamera2 object's preview_configuration field).

        capture_mode - the camera mode to use to capture the still images (defaulting to the
            Picamera2 object's still_configuration field).

        show_preview - whether to show a preview window (default: yes). The preview window only
            displays an image by default during the preview phase. This parameter only has any
            effect if a preview is not already running. If it is, it would have to be stopped first
            (with the stop_preview method).

        exif_data - dictionary containing user defined exif data (based on `piexif`). This will
            overwrite existing exif information generated by picamera2.
        """
        ...
    
    def start_and_record_video(self, output, encoder=..., config=..., quality=..., show_preview=..., duration=..., audio=...): # -> None:
        """This function makes video recording more convenient.

        Should only be used in command line applications (not from a Qt application, for example).
        It will configure the camera if requested and start it. The following parameters are required:

        output - the name of an output file (or an output object). If the output is a string,
            the correct output object will be created for "mp4" or "ts" files. All other formats
            will simply be written as flat files.

        The following parameters are optional:

        encoder - the encoder object to use. If unspecified, the MJPEGEncoder will be selected for
            files ending in ".mjpg" or .mjpeg", otherwise the H264Enccoder will be used.

        config - the camera configuration to apply. The default behaviour (given by the value None)
            is not to overwrite any existing configuration, though the "video" configuration will be
            applied if the camera is unconfigured.

        quality - an indication of the video quality to use. This will be ignored if the encoder
            object was created with all its quality parameters (such as bitrate) filled in.

        show_preview - whether to show a preview window (default: no). This parameter only has an
            effect if a preview is not already running, in which case that preview would need
            stopping first (using stop_preview) for any change to take effect.

        duration - the duration of the video. The function will wait this amount of time before
            stopping the recording and returning. The default behaviour is to return immediately
            and to leave the recoding running (the application will have to stop it later, for
            example by calling stop_recording).

        audio - whether to record audio. This is only effective when recording to an "mp4" or "ts"
            file, and there is a microphone installed and working as the default input device
            through Pulseaudio.
        """
        ...
    
    def autofocus_cycle(self, wait=..., signal_function=...): # -> None:
        """Switch autofocus to auto mode and run an autofocus cycle.

        Return True if the autofocus cycle focuses successuly, otherwise False.
        """
        ...
    


